var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/seclang/syntax/",title:"Syntax",description:`The original language for configuring the ModSecurity Apache module was a set of extension directives to the Apache config language. This extension allows you to generate your Security Policy where you take an access control decision based on a set of parameters. Directives can be used to configure the engine itself, but also to send directives to the engine for access control. Directives look like the examples below:
SecDirective1 some options SecDirective2 \u0026quot;some option between brackets \\\u0026quot; and escaped\u0026quot; SecSampleDirective this \\ directive \\ is splitted \\ in lines Rule syntax # Rules are a special directive that must contain variables, operator and actions: SecRule VARIABLES \u0026quot;@OPERATOR OPERATOR_ARGUMENTS\u0026quot; \u0026quot;ACTIONS\u0026quot;.`,content:`The original language for configuring the ModSecurity Apache module was a set of extension directives to the Apache config language. This extension allows you to generate your Security Policy where you take an access control decision based on a set of parameters. Directives can be used to configure the engine itself, but also to send directives to the engine for access control. Directives look like the examples below:
SecDirective1 some options SecDirective2 \u0026quot;some option between brackets \\\u0026quot; and escaped\u0026quot; SecSampleDirective this \\ directive \\ is splitted \\ in lines Rule syntax # Rules are a special directive that must contain variables, operator and actions: SecRule VARIABLES \u0026quot;@OPERATOR OPERATOR_ARGUMENTS\u0026quot; \u0026quot;ACTIONS\u0026quot;.
All rules must have a unique ID action, for example \u0026quot;id:1\u0026quot;. If there is no phase action, the phase will default to 2 (request headers). Rules can contain only one disruptive action More default actions can be set with SecDefaultAction SecRule REMOTE_ADDR \u0026quot;127.0.0.1\u0026quot; \u0026quot;id:1, phase:1, pass, log, logdata:'Request from localhost'\u0026quot; Variables # Variables are a structure of KEY:VALUE(S), some variables are mapped objects that contains KEY:[VALUE1,VALUE2,VALUE3], while other are just KEY:VALUE. If you request a variable without any parameter, it will return all of values for each key, if it is a KEY:VALUE variable it will just return a single value. Variable parameters use the syntax VARIABLE:PARAMETER.
Variable key
Variables can be queried for a specific case insesitive key, for example:
SecRule REQUEST_HEADERS:user-agent \u0026quot;@contains firefox\u0026quot; \u0026quot;id:1, pass, log, logdata:'someone used firefox to access'\u0026quot; Variable with regex
(v2 Only): PCRE compatible regex can be used to query a mapped VARIABLE like ARGS, the following example will match all parameters (get and post) where the key begins with param and the value of this argument is someval.
SecRule ARGS:/^param.*$/ \u0026quot;someval\u0026quot; \u0026quot;id:1\u0026quot; ðŸ‘‰ Only RE2 will be supported in v3. Variable exceptions
You can remove specific taget keys from the variables list using the ! prefix, for example:
# We want to apply some Sql Injection validations against the REQUEST_HEADERS SecRule REQUEST_HEADERS \u0026quot;@detectSQLi\u0026quot; \u0026quot;id:1,deny,status:403\u0026quot; # There is a false positive for some User-Agents so we want to ignore the # User-Agent header: SecRule REQUEST_HEADERS|!REQUEST_HEADERS:User-Agent \u0026quot;@detectSQLi\u0026quot; \u0026quot;id:2,deny,status:403\u0026quot; ## The second rule will be evaluated for each request header except User-Agent. XPATH variables # If the body processor is set to process JSON or XML, you may use the special variables XML and JSON, for example:
SecAction \u0026quot;id:1, phase:1,ctl:setRequestBodyProcessor=XML,pass,nolog\u0026quot; # We are denying a book because we don't like it SecRule XML:/bookstore/book[last()] \u0026quot;name of the book\u0026quot; \u0026quot;id:2,phase:2,log,logdata:'We donÂ´t like this book!',deny,status:403\u0026quot; See https://github.com/antchfx/xpath for more information about XPATH support.
Variable count
You can count the number of keys available for a collection using the \u0026amp; prefix, for example:
# You want to block requests without host header SecRule \u0026amp;REQUEST_HEADERS:text \u0026quot;@eq 0\u0026quot; \u0026quot;id:1, deny, status:403\u0026quot; Multiple Variables
You may evaluate multiple variables by separating them win pipe (|), for example:
SecRule VARIABLE1|VARIABLE2|VARIABLE3:/some-regex/|\u0026amp;VARIABLE4|!VARIABLE3:id \u0026quot;!@rx \\w+\u0026quot; \u0026quot;id:1,pass\u0026quot; Operators # Operators are functions that returns true or false. Only one operator can be used per rule, unless you use chains. The syntax for an operator is: \u0026quot;@OPERATOR ARGUMENTS\u0026quot;, you can negate the result using \u0026quot;!@OPERATOR ARGUMENTS\u0026quot;.
ðŸ‘‰ If you don\u0026rsquo;t indicate any operator, the default used operator will be @rx.
Operators must begin with @.
Actions # Actions are key-value instructions for the rule that will be triggered per compilation, interruption or transaction depending on the action type.
Actions values are optional, the key-value syntax is key:value and some actions can be reused as much as you want, like t.
Action types:
Non-disruptive actions - Do something, but that something does not and cannot affect the rule processing flow. Setting a variable, or changing its value is an example of a non-disruptive action. Non-disruptive action can appear in any rule, including each rule belonging to a chain. Flow actions - These actions affect the rule flow (for example skip or skipAfter). Meta-data actions - Meta-data actions are used to provide more information about rules. Examples include id, rev, severity and msg. Data actions - Not really actions, these are mere containers that hold data used by other actions. For example, the status action holds the status that will be used for blocking (if it takes place). Default Actions # SecDefaultAction is used to define a default list of actions per phase. The default phases will be added to each rule and can be overwritten by using the specified action again.
If you define default actions, you are forced to indicate a phase and a disruptive action.
SecDefaultAction \u0026quot;phase:1, deny, status:403\u0026quot; # This rule will deny the request with status 403 because of the default actions SecAction \u0026quot;id:2, phase:1\u0026quot; # This rule will be triggered but it will pas instead of deny SecAction \u0026quot;id:3, phase:1, pass\u0026quot; SecAction # SecActions are used to create rules that will always match, they donÂ´t contain operator nor variables.
Macro Expansion # Macro expansions are special messages that can be transformed into it\u0026rsquo;s evaluated value, the syntax is: %{VARIABLE.KEY}, for example %{REQUEST_HEADERS:host} will return the content of the request header \u0026ldquo;Host\u0026rdquo;.
SecAction \u0026quot;id:1, log, logdata:'Transaction %{unique_id}'\u0026quot; # we assign a variable to tx.argcount SecRule \u0026amp;ARGS \u0026quot;!@eq 0\u0026quot; \u0026quot;id:2, setvar:'tx.argcount=%{MATCHED_VAR}', pass\u0026quot; # we print the args count to the log SecAction \u0026quot;id:3, log, logdata:'%{tx.argcount} arguments found.'\u0026quot; `}),e.add({id:1,href:"/docs/seclang/directives/",title:"Directives",description:"The following section outlines all of the Coraza directives. ",content:""}),e.add({id:2,href:"/docs/seclang/actions/",title:"Actions",description:"Actions available in Coraza",content:`Actions are defined as part of a SecRule or as parameter for SecAction or SecDefaultAction. A rule can have no or serveral actions which need to be separated by a comma.
Actions can be categorized by how they affect overall processing:
Disruptive actions - Cause Coraza to do something. In many cases something means block transaction, but not in all. For example, the allow action is classified as a disruptive action, but it does the opposite of blocking. There can only be one disruptive action per rule (if there are multiple disruptive actions present, or inherited, only the last one will take effect), or rule chain (in a chain, a disruptive action can only appear in the first rule). ðŸ‘‰ Disruptive actions will NOT be executed if the SecRuleEngine is set to DetectionOnly. If you are creating exception/whitelisting rules that use the allow action, you should also add the ctl:ruleEngine=On action to execute the action. Non-disruptive actions - Do something, but that something does not and cannot affect the rule processing flow. Setting a variable, or changing its value is an example of a non-disruptive action. Non-disruptive action can appear in any rule, including each rule belonging to a chain. Flow actions - These actions affect the rule flow (for example skip or skipAfter). Meta-data actions - used to provide more information about rules. Examples include id, rev, severity and msg. Data actions - Not really actions, these are mere containers that hold data used by other actions. For example, the status action holds the status that will be used for blocking (if it takes place). accuracy # Description: Specifies the relative accuracy level of the rule related to false positives/negatives. The value is a string based on a numeric scale (1-9 where 9 is very strong and 1 has many false positives).
Action Group: Meta-data
Example:
SecRule REQUEST_FILENAME|ARGS_NAMES|ARGS|XML:/* \u0026quot;\\bgetparentfolder\\b\u0026quot; \\ \u0026quot;id:'958016',phase:2,ver:'CRS/2.2.4,accuracy:'9',maturity:'9',capture,\\ t:none,t:htmlEntityDecode,t:compressWhiteSpace,t:lowercase,\\ ctl:auditLogParts=+E,block,msg:'Cross-site Scripting (XSS) Attack',\\ tag:'WEB_ATTACK/XSS',tag:'WASCTC/WASC-8',tag:'WASCTC/WASC-22',tag:'OWASP_TOP_10/A2',\\ tag:'OWASP_AppSensor/IE1',tag:'PCI/6.5.1',logdata:'%{TX.0}',\\ severity:'2',setvar:'tx.msg=%{rule.msg}',\\ setvar:tx.xss_score=+%{tx.critical_anomaly_score},\\ setvar:tx.anomaly_score=+%{tx.critical_anomaly_score},\\ setvar:tx.%{rule.id}-WEB_ATTACK/XSS-%{matched_var_name}=%{tx.0}\u0026quot; allow # Description: Stops rule processing on a successful match and allows the transaction to proceed.
Action Group: Disruptive
Example:
# Allow unrestricted access from 192.168.1.100 SecRule REMOTE_ADDR \u0026quot;^192\\.168\\.1\\.100$\u0026quot; phase:1,id:95,nolog,allow Prior to Coraza 2.5 the allow action would only affect the current phase. An allow in phase 1 would skip processing the remaining rules in phase 1 but the rules from phase 2 would execute. Starting with v2.5.0 allow was enhanced to allow for fine-grained control of what is done. The following rules now apply:
If used on its own, like in the example above, allow will affect the entire transaction, stopping processing of the current phase, but also skipping over all other phases apart from the logging phase. (The logging phase is special; it is designed to always execute.) If used with parameter \u0026ldquo;phase\u0026rdquo;, allow will cause the engine to stop processing the current phase. Other phases will continue as normal. If used with parameter \u0026ldquo;request\u0026rdquo;, allow will cause the engine to stop processing the current phase. The next phase to be processed will be phase RESPONSE_HEADERS. Examples:
# Do not process request but process response. SecAction phase:1,allow:request,id:96 # Do not process transaction (request and response). SecAction phase:1,allow,id:97 If you want to allow a response through, put a rule in phase RESPONSE_HEADERS and simply use allow on its own: # Allow response through. SecAction phase:3,allow,id:98 append # Description: Appends text given as parameter to the end of response body. Content injection must be enabled (using the SecContentInjection directive). No content type checks are made, which means that before using any of the content injection actions, you must check whether the content type of the response is adequate for injection.
Action Group: Non-disruptive
Processing Phases: 3 and 4.
Example:
SecRule RESPONSE_CONTENT_TYPE \u0026quot;^text/html\u0026quot; \u0026quot;nolog,id:99,pass,append:'\u0026lt;hr\u0026gt;Footer'\u0026quot; Warning : Although macro expansion is allowed in the additional content, you are strongly cautioned against inserting user-defined data fields into output. Doing so would create a cross-site scripting vulnerability.
auditlog # Description: Marks the transaction for logging in the audit log.
Action Group: Non-disruptive
Example:
SecRule REMOTE_ADDR \u0026quot;^192\\.168\\.1\\.100$\u0026quot; \u0026quot;auditlog,phase:1,id:100,allow\u0026quot; Note : The auditlog action is now explicit if log is already specified.
block # Description: Performs the disruptive action defined by the previous SecDefaultAction.
Action Group: Disruptive
This action is essentially a placeholder that is intended to be used by rule writers to request a blocking action, but without specifying how the blocking is to be done. The idea is that such decisions are best left to rule users, as well as to allow users, to override blocking if they so desire. In future versions of Coraza, more control and functionality will be added to define \u0026ldquo;how\u0026rdquo; to block.
Examples:
# Specify how blocking is to be done SecDefaultAction \u0026quot;phase:2,deny,id:101,status:403,log,auditlog\u0026quot; # Detect attacks where we want to block SecRule ARGS \u0026quot;@rx attack1\u0026quot; \u0026quot;phase:2,block,id:102\u0026quot; # Detect attacks where we want only to warn SecRule ARGS \u0026quot;@rx attack2\u0026quot; \u0026quot;phase:2,pass,id:103\u0026quot; It is possible to use the SecRuleUpdateActionById directive to override how a rule handles blocking. This is useful in three cases:
If a rule has blocking hard-coded, and you want it to use the policy you determine If a rule was written to block, but you want it to only warn If a rule was written to only warn, but you want it to block The following example demonstrates the first case, in which the hard-coded block is removed in favor of the user-controllable block:
# Specify how blocking is to be done SecDefaultAction \u0026quot;phase:2,deny,status:403,log,auditlog,id:104\u0026quot; # Detect attacks and block SecRule ARGS \u0026quot;@rx attack1\u0026quot; \u0026quot;phase:2,id:1,deny\u0026quot; # Change how rule ID 1 blocks SecRuleUpdateActionById 1 \u0026quot;block\u0026quot; capture # Description: When used together with the regular expression operator @rx, the capture action creates a copy of the regular expression captures and places them into the transaction variable collection.
Action Group: Non-disruptive
Example:
SecRule REQUEST_BODY \u0026quot;^username=(\\w{25,})\u0026quot; phase:2,capture,t:none,chain,id:105 SecRule TX:1 \u0026quot;(?:(?:a(dmin|nonymous)))\u0026quot; Up to 10 captures will be copied on a successful pattern match, each with a name consisting of a digit from 0 to 9. The TX.0 variable always contains the entire area that the regular expression matched. All the other variables contain the captured values, in the order in which the capturing parentheses appear in the regular expression.
**This action is being forced by now, it might be reused in the future)
chain # Description: Chains the current rule with the rule that immediately follows it, creating a rule chain. Chained rules allow for more complex processing logic.
Action Group: Flow
Example:
# Refuse to accept POST requests that do not contain a Content-Length header. # # Note: this rule should be preceded by a rule that verifies only valid # request methods are used. SecRule REQUEST_METHOD \u0026quot;^POST$\u0026quot; \u0026quot;phase:1,chain,t:none,id:105\u0026quot; SecRule \u0026amp;REQUEST_HEADERS:Content-Length \u0026quot;@eq 0\u0026quot; \u0026quot;t:none\u0026quot; Note : Rule chains allow you to simulate logical AND. The disruptive actions specified in the first portion of the chained rule will be triggered only if all of the variable checks return positive hits. If any one aspect of a chained rule comes back negative, then the entire rule chain will fail to match. Also note that disruptive actions, execution phases, metadata actions (id, rev, msg, tag, severity, logdata), skip, and skipAfter actions can be specified only by the chain starter rule. The following directives can be used in rule chains:
SecAction SecRule SecRuleScript Special rules control the usage of actions in chained rules:
Any actions that affect the rule flow (i.e., the disruptive actions, skip and skipAfter) can be used only in the chain starter. They will be executed only if the entire chain matches. Non-disruptive rules can be used in any rule; they will be executed if the rule that contains them matches and not only when the entire chain matches. The metadata actions (e.g., id, rev, msg) can be used only in the chain starter. ctl # Description: Changes Coraza configuration on transient, per-transaction basis. Any changes made using this action will affect only the transaction in which the action is executed. The default configuration, as well as the other transactions running in parallel, will be unaffected.
Action Group: Non-disruptive
Example:
# Parse requests with Content-Type \u0026quot;text/xml\u0026quot; as XML SecRule REQUEST_CONTENT_TYPE ^text/xml \u0026quot;nolog,pass,id:106,ctl:requestBodyProcessor=XML\u0026quot; # white-list the user parameter for rule #981260 when the REQUEST_URI is /index.php SecRule REQUEST_URI \u0026quot;@beginsWith /index.php\u0026quot; \u0026quot;phase:1,t:none,pass,\\ nolog,ctl:ruleRemoveTargetById=981260;ARGS:user\u0026quot; The following configuration options are supported:
auditEngine auditLogParts debugLogLevel forceRequestBodyVariable requestBodyAccess requestBodyLimit requestBodyProcessor responseBodyAccess responseBodyLimit ruleEngine ruleRemoveById - since this action us triggered at run time, it should be specified before the rule in which it is disabling. ruleRemoveByMsg ruleRemoveByTag ruleRemoveTargetById - since this action is used to just remove targets, users don\u0026rsquo;t need to use the char ! before the target list. ruleRemoveTargetByMsg - since this action is used to just remove targets, users don\u0026rsquo;t need to use the char ! before the target list. ruleRemoveTargetByTag - since this action is used to just remove targets, users don\u0026rsquo;t need to use the char ! before the target list. hashEngine (Supported on Coraza: TBI) hashEnforcement (Supported on Coraza: TBI) With the exception of the requestBodyProcessor and forceRequestBodyVariable settings, each configuration option corresponds to one configuration directive and the usage is identical.
The requestBodyProcessor option allows you to configure the request body processor. By default, Coraza will use the URLENCODED and MULTIPART processors to process an application/x-www-form-urlencoded and a multipart/form-data body, respectively. Other two processors are also supported: JSON and XML, but they are never used implicitly. Instead, you must tell Coraza to use it by placing a few rules in the REQUEST_HEADERS processing phase. After the request body is processed as XML, you will be able to use the XML-related features to inspect it.
Request body processors will not interrupt a transaction if an error occurs during parsing. Instead, they will set the variables REQBODY_PROCESSOR_ERROR and REQBODY_PROCESSOR_ERROR_MSG. These variables should be inspected in the REQUEST_BODY phase and an appropriate action taken. The forceRequestBodyVariable option allows you to configure the REQUEST_BODY variable to be set when there is no request body processor configured. This allows for inspection of request bodies of unknown types.
deny # Description: Stops rule processing and intercepts transaction.
Action Group: Disruptive
Example:
SecRule REQUEST_HEADERS:User-Agent \u0026quot;nikto\u0026quot; \u0026quot;log,deny,id:107,msg:'Nikto Scanners Identified'\u0026quot; drop # Description: Initiates an immediate close of the TCP connection by sending a FIN packet.
Action Group: Disruptive
Example: The following example initiates an IP collection for tracking Basic Authentication attempts. If the client goes over the threshold of more than 25 attempts in 2 minutes, it will DROP subsequent connections.
SecAction phase:1,id:109,initcol:ip=%{REMOTE_ADDR},nolog SecRule ARGS:login \u0026quot;!^$\u0026quot; \u0026quot;nolog,phase:1,id:110,setvar:ip.auth_attempt=+1,deprecatevar:ip.auth_attempt=25/120\u0026quot; SecRule IP:AUTH_ATTEMPT \u0026quot;@gt 25\u0026quot; \u0026quot;log,drop,phase:1,id:111,msg:'Possible Brute Force Attack'\u0026quot; Note : This action depends on each implementation, the server is instructed to drop the connection.
This action is extremely useful when responding to both Brute Force and Denial of Service attacks in that, in both cases, you want to minimize both the network bandwidth and the data returned to the client. This action causes error message to appear in the log \u0026ldquo;(9)Bad file descriptor: core_output_filter: writing data to the network\u0026rdquo;
exec # Description: Executes an external script/binary supplied as parameter.
Action Group: Non-disruptive
Example:
# Run external program on rule match SecRule REQUEST_URI \u0026quot;^/cgi-bin/script\\.pl\u0026quot; \u0026quot;phase:2,id:112,t:none,t:lowercase,t:normalizePath,block,\\ exec:/usr/local/apache/bin/test.sh\u0026quot; # Run Lua script on rule match SecRule ARGS:p attack \u0026quot;phase:2,id:113,block,exec:/usr/local/apache/conf/exec.lua\u0026quot; The exec action is executed independently from any disruptive actions specified. External scripts will always be called with no parameters. Some transaction information will be placed in environment variables. All the usual CGI environment variables will be there. You should be aware that forking a threaded process results in all threads being replicated in the new process. Forking can therefore incur larger overhead in a multithreaded deployment. The script you execute must write something (anything) to stdout; if it doesnâ€™t, Coraza will assume that the script failed, and will record the failure.
expirevar # Description: Configures a collection variable to expire after the given time period (in seconds).
Supported on Coraza: TBI
Action Group: Non-disruptive
Example:
SecRule REQUEST_COOKIES:JSESSIONID \u0026quot;!^$\u0026quot; \u0026quot;nolog,phase:1,id:114,pass,setsid:%{REQUEST_COOKIES:JSESSIONID}\u0026quot; SecRule REQUEST_URI \u0026quot;^/cgi-bin/script\\.pl\u0026quot; \u0026quot;phase:2,id:115,t:none,t:lowercase,t:normalizePath,log,allow,\\ setvar:session.suspicious=1,expirevar:session.suspicious=3600,phase:1\u0026quot; You should use the expirevar actions at the same time that you use setvar actions in order to keep the intended expiration time. If they are used on their own (perhaps in a SecAction directive), the expire time will be reset.
id # Description: Assigns a unique ID to the rule or chain in which it appears. This action is mandatory and must be numeric.
Action Group: Meta-data
Example:
SecRule \u0026amp;REQUEST_HEADERS:Host \u0026quot;@eq 0\u0026quot; \u0026quot;log,id:60008,severity:2,msg:'Request Missing a Host Header'\u0026quot; Note : The id action is required for all SecRule/SecAction.
initcol # Description: Initializes a named persistent collection, either by loading data from storage or by creating a new collection in memory.
Action Group: Non-disruptive
Supported on Coraza: TBI
Example: The following example initiates IP address tracking, which is best done in phase 1:
SecAction \u0026quot;phase:1,id:116,nolog,pass,initcol:ip=%{REMOTE_ADDR}\u0026quot; Collections are loaded into memory on-demand, when the initcol action is executed. A collection will be persisted only if a change was made to it in the course of transaction processing.
See the \u0026ldquo;Persistent Storage\u0026rdquo; section for further details.
log # Description: Indicates that a successful match of the rule needs to be logged.
Action Group: Non-disruptive
Example:
SecAction \u0026quot;phase:1,id:117,pass,initcol:ip=%{REMOTE_ADDR},log\u0026quot; This action will log matches to the Apache error log file and the Coraza audit log.
logdata # Description: Logs a data fragment as part of the alert message.
Action Group: Non-disruptive
Example:
SecRule ARGS:p \u0026quot;@rx \u0026lt;script\u0026gt;\u0026quot; \u0026quot;phase:2,id:118,log,pass,logdata:%{MATCHED_VAR}\u0026quot; The logdata information appears in the error and/or audit log files. Macro expansion is performed, so you may use variable names such as %{TX.0} or %{MATCHED_VAR}. The information is properly escaped for use with logging of binary data.
maturity # Description: Specifies the relative maturity level of the rule related to the length of time a rule has been public and the amount of testing it has received. The value is a string based on a numeric scale (1-9 where 9 is extensively tested and 1 is a brand new experimental rule).
Action Group: Meta-data
Example:
SecRule REQUEST_FILENAME|ARGS_NAMES|ARGS|XML:/* \u0026quot;\\bgetparentfolder\\b\u0026quot; \\ \u0026quot;phase:2,ver:'CRS/2.2.4,accuracy:'9',maturity:'9',capture,t:none,t:htmlEntityDecode,t:compressWhiteSpace,t:lowercase,ctl:auditLogParts=+E,block,msg:'Cross-site Scripting (XSS) Attack',id:'958016',tag:'WEB_ATTACK/XSS',tag:'WASCTC/WASC-8',tag:'WASCTC/WASC-22',tag:'OWASP_TOP_10/A2',tag:'OWASP_AppSensor/IE1',tag:'PCI/6.5.1',logdata:'% \\ {TX.0}',severity:'2',setvar:'tx.msg=%{rule.msg}',setvar:tx.xss_score=+%{tx.critical_anomaly_score},setvar:tx.anomaly_score=+%{tx.critical_anomaly_score},setvar:tx.%{rule.id}-WEB_ATTACK/XSS-%{matched_var_name}=%{tx.0}\u0026quot; msg # Description: Assigns a custom message to the rule or chain in which it appears. The message will be logged along with every alert.
Action Group: Meta-data
Example:
SecRule \u0026amp;REQUEST_HEADERS:Host \u0026quot;@eq 0\u0026quot; \u0026quot;log,id:60008,severity:2,msg:'Request Missing a Host Header'\u0026quot; Note : The msg information appears in the error and/or audit log files and is not sent back to the client in response headers.
multiMatch # Description: If enabled, Coraza will perform multiple operator invocations for every target, before and after every anti-evasion transformation is performed.
Action Group: Non-disruptive
Example:
SecRule ARGS \u0026quot;attack\u0026quot; \u0026quot;phase1,log,deny,id:119,t:removeNulls,t:lowercase,multiMatch\u0026quot; Normally, variables are inspected only once per rule, and only after all transformation functions have been completed. With multiMatch, variables are checked against the operator before and after every transformation function that changes the input.
noauditlog # Description: Indicates that a successful match of the rule should not be used as criteria to determine whether the transaction should be logged to the audit log.
Action Group: Non-disruptive
Example:
SecRule REQUEST_HEADERS:User-Agent \u0026quot;@streq Test\u0026quot; \u0026quot;allow,noauditlog,id:120\u0026quot; If the SecAuditEngine is set to On, all of the transactions will be logged. If it is set to RelevantOnly, then you can control the logging with the noauditlog action.
The noauditlog action affects only the current rule. If you prevent audit logging in one rule only, a match in another rule will still cause audit logging to take place. If you want to prevent audit logging from taking place, regardless of whether any rule matches, use ctl:auditEngine=Off.
nolog # Description: Prevents rule matches from appearing in both the error and audit logs.
Action Group: Non-disruptive
Example:
SecRule REQUEST_HEADERS:User-Agent \u0026quot;@streq Test\u0026quot; \u0026quot;allow,nolog,id:121\u0026quot; Although nolog implies noauditlog, you can override the former by using nolog,auditlog.
pass # Description: Continues processing with the next rule in spite of a successful match.
Action Group: Disruptive
Example:
SecRule REQUEST_HEADERS:User-Agent \u0026quot;@streq Test\u0026quot; \u0026quot;log,pass,id:122\u0026quot; When using pass with a SecRule with multiple targets, all variables will be inspected and all non-disruptive actions trigger for every match. In the following example, the TX.test variable will be incremented once for every request parameter:
# Set TX.test to zero SecAction \u0026quot;phase:2,nolog,pass,setvar:TX.test=0,id:123\u0026quot; # Increment TX.test for every request parameter SecRule ARGS \u0026quot;test\u0026quot; \u0026quot;phase:2,log,pass,setvar:TX.test=+1,id:124\u0026quot; pause # Description: Pauses transaction processing for the specified number of milliseconds. This feature also supports macro expansion.
Action Group: Disruptive
Example:
SecRule REQUEST_HEADERS:User-Agent \u0026quot;Test\u0026quot; \u0026quot;log,pause:5000,id:125\u0026quot; Warning : This feature can be of limited benefit for slowing down brute force authentication attacks, but use with care. If you are under a denial of service attack, the pause feature may make matters worse, as it will cause an entire Apache worker (process or thread, depending on the deployment mode) to sit idle until the pause is completed.
phase # Description: Places the rule or chain into one of five available processing phases. It can also be used in SecDefaultAction to establish the rule defaults.
Action Group: Meta-data
Example:
# Initialize IP address tracking in phase 1 SecAction phase:1,nolog,pass,id:126,initcol:IP=%{REMOTE_ADDR} There are aliases for some phase numbers:
2 - request 4 - response 5 - logging Example:
SecRule REQUEST_HEADERS:User-Agent \u0026quot;Test\u0026quot; \u0026quot;phase:request,log,deny,id:127\u0026quot; Warning : Keep in mind that if you specify the incorrect phase, the variable used in the rule may not yet be available. This could lead to a false negative situation where your variable and operator may be correct, but it misses malicious data because you specified the wrong phase.
prepend # Description: Prepends the text given as parameter to response body. Content injection must be enabled (using the SecContentInjection directive). No content type checks are made, which means that before using any of the content injection actions, you must check whether the content type of the response is adequate for injection.
Action Group: Non-disruptive
Processing Phases: 3 and 4.
Example:
SecRule RESPONSE_CONTENT_TYPE \u0026quot;^text/html\u0026quot; \u0026quot;phase:3,nolog,pass,id:128,prepend:'Header\u0026lt;br\u0026gt;'\u0026quot; Warning : Although macro expansion is allowed in the injected content, you are strongly cautioned against inserting user defined data fields int output. Doing so would create a cross-site scripting vulnerability.
proxy # Description: Intercepts the current transaction by forwarding the request to another web server using the proxy backend. The forwarding is carried out transparently to the HTTP client (i.e., thereâ€™s no external redirection taking place).
Action Group: Disruptive
Example:
SecRule REQUEST_HEADERS:User-Agent \u0026quot;@streq Test\u0026quot; \u0026quot;log,id:129,proxy:http://honeypothost/\u0026quot; SecRule REQUEST_URI \u0026quot;@streq /test.txt\u0026quot; \u0026quot;phase:1,proxy:'http://$ENV{SERVER_NAME}:$ENV{SERVER_PORT}/test.txt',id:500005\u0026quot; For this action to work, the implementation must handle the proxy connection after the interruption notification.
redirect # Description: Intercepts transaction by issuing an external (client-visible) redirection to the given location..
Action Group: Disruptive
Example:
SecRule REQUEST_HEADERS:User-Agent \u0026quot;@streq Test\u0026quot; \u0026quot;phase:1,id:130,log,redirect:http://www.example.com/failed.html\u0026quot; If the status action is present on the same rule, and its value can be used for a redirection (i.e., is one of the following: 301, 302, 303, or 307), the value will be used for the redirection status code. Otherwise, status code 302 will be used.
rev # Description: Specifies rule revision. It is useful in combination with the id action to provide an indication that a rule has been changed.
Action Group: Meta-data
Example:
SecRule REQUEST_FILENAME|ARGS_NAMES|ARGS|XML:/* \u0026quot;(?:(?:[\\;\\|\\\`]\\W*?\\bcc|\\b(wget|curl))\\b|\\/cc(?:[\\'\\\u0026quot;\\|\\;\\\`\\-\\s]|$))\u0026quot; \\ \u0026quot;phase:2,rev:'2.1.3',capture,t:none,t:normalizePath,t:lowercase,ctl:auditLogParts=+E,block,msg:'System Command Injection',id:'950907',tag:'WEB_ATTACK/COMMAND_INJECTION',tag:'WASCTC/WASC-31',tag:'OWASP_TOP_10/A1',tag:'PCI/6.5.2',logdata:'%{TX.0}',severity:'2',setvar:'tx.msg=%{rule.msg}',setvar:tx.anomaly_score=+%{tx.critical_anomaly_score},setvar:tx.command_injection_score=+%{tx.critical_anomaly_score},setvar:tx.%{rule.id}-WEB_ATTACK/COMMAND_INJECTION-%{matched_var_name}=%{tx.0},skipAfter:END_COMMAND_INJECTION1\u0026quot; Note : This action is used in combination with the id action to allow the same rule ID to be used after changes take place but to still provide some indication the rule changed.
sanitiseArg # Description: Prevents sensitive request parameter data from being logged to audit log. Each byte of the named parameter(s) is replaced with an asterisk.
Supported on Coraza: TBI
Action Group: Non-disruptive
Example:
# Never log passwords SecAction \u0026quot;nolog,phase:2,id:131,sanitiseArg:password,sanitiseArg:newPassword,sanitiseArg:oldPassword\u0026quot; Note : The sanitize actions affect only the data as it is logged to audit log. High-level debug logs may contain sensitive data. Apache access log may contain sensitive data placed in the request URI.
sanitiseMatched # Description: Prevents the matched variable (request argument, request header, or response header) from being logged to audit log. Each byte of the named parameter(s) is replaced with an asterisk.
Supported on Coraza: TBI
Action Group: Non-disruptive
Example: This action can be used to sanitise arbitrary transaction elements when they match a condition. For example, the example below will sanitise any argument that contains the word password in the name.
SecRule ARGS_NAMES password nolog,pass,id:132,sanitiseMatched Note : The sanitize actions affect only the data as it is logged to audit log. High-level debug logs may contain sensitive data. Apache access log may contain sensitive data placed in the request URI.
sanitiseMatchedBytes # Description: Prevents the matched string in a variable from being logged to audit log. Each or a range of bytes of the named parameter(s) is replaced with an asterisk.
Supported on Coraza: TBI
Action Group: Non-disruptive
Example: This action can be used to sanitise arbitrary transaction elements when they match a condition. For example, the example below will sanitise the credit card number.
sanitiseMatchedBytes \u0026ndash; This would x out only the bytes that matched. sanitiseMatchedBytes:1/4 \u0026ndash; This would x out the bytes that matched, but keep the first byte and last 4 bytes # Detect credit card numbers in parameters and # prevent them from being logged to audit log SecRule ARGS \u0026quot;@verifyCC \\d{13,16}\u0026quot; \u0026quot;phase:2,id:133,nolog,capture,pass,msg:'Potential credit card number in request',sanitiseMatchedBytes\u0026quot; SecRule RESPONSE_BODY \u0026quot;@verifyCC \\d{13,16}\u0026quot; \u0026quot;phase:4,id:134,t:none,log,capture,block,msg:'Potential credit card number is response body',sanitiseMatchedBytes:0/4\u0026quot; Note : The sanitize actions affect only the data as it is logged to audit log. High-level debug logs may contain sensitive data. Apache access log may contain sensitive data placed in the request URI. You must use capture action with sanitiseMatchedBytes, so the operator must support capture action. ie: @rx, @verifyCC.
sanitiseRequestHeader # Description: Prevents a named request header from being logged to audit log. Each byte of the named request header is replaced with an asterisk.
Supported on Coraza: TBI
Action Group: Non-disruptive
Example: This will sanitise the data in the Authorization header.
SecAction \u0026quot;phase:1,nolog,pass,id:135,sanitiseRequestHeader:Authorization\u0026quot; Note : The sanitize actions affect only the data as it is logged to audit log. High-level debug logs may contain sensitive data. Apache access log may contain sensitive data placed in the request URI.
sanitiseResponseHeader # Description: Prevents a named response header from being logged to audit log. Each byte of the named response header is replaced with an asterisk.
Supported on Coraza: TBI
Action Group: Non-disruptive
Example: This will sanitise the Set-Cookie data sent to the client.
SecAction \u0026quot;phase:3,nolog,pass,id:136,sanitiseResponseHeader:Set-Cookie\u0026quot; Note : The sanitize actions affect only the data as it is logged to audit log. High-level debug logs may contain sensitive data. Apache access log may contain sensitive data placed in the request URI.
severity # Description: Assigns severity to the rule in which it is used.
Action Group: Meta-data
Example:
SecRule REQUEST_METHOD \u0026quot;^PUT$\u0026quot; \u0026quot;id:340002,rev:1,severity:CRITICAL,msg:'Restricted HTTP function'\u0026quot; Severity values in Coraza follows the numeric scale of syslog (where 0 is the most severe). The data below is used by the OWASP Core Rule Set (CRS):
0 - EMERGENCY: is generated from correlation of anomaly scoring data where there is an inbound attack and an outbound leakage. 1 - ALERT: is generated from correlation where there is an inbound attack and an outbound application level error. 2 CRITICAL: Anomaly Score of 5. Is the highest severity level possible without correlation. It is normally generated by the web attack rules (40 level files). 3 - ERROR: Error - Anomaly Score of 4. Is generated mostly from outbound leakage rules (50 level files). 4 - WARNING: Anomaly Score of 3. Is generated by malicious client rules (35 level files). 5 - NOTICE: Anomaly Score of 2. Is generated by the Protocol policy and anomaly files. 6 - INFO 7 - DEBUG It is possible to specify severity levels using either the numerical values or the text values, but you should always specify severity levels using the text values, because it is difficult to remember what a number stands for. The use of the numerical values is deprecated as of version 2.5.0 and may be removed in one of the subsequent major updates.
setuid # Description: Special-purpose action that initializes the USER collection using the username provided as parameter.
Action Group: Non-disruptive
Supported on Coraza: TBI
Example:
SecRule ARGS:username \u0026quot;.*\u0026quot; \u0026quot;phase:2,id:137,t:none,pass,nolog,noauditlog,capture,setvar:session.username=%{TX.0},setuid:%{TX.0}\u0026quot; After initialization takes place, the variable USERID will be available for use in the subsequent rules. This action understands application namespaces (configured using SecWebAppId), and will use one if it is configured.
setrsc # Description: Special-purpose action that initializes the RESOURCE collection using a key provided as parameter.
Action Group: Non-disruptive
Supported on Coraza: TBI
Example:
SecAction \u0026quot;phase:1,pass,id:3,log,setrsc:'abcd1234'\u0026quot; This action understands application namespaces (configured using SecWebAppId), and will use one if it is configured.
setsid # Description: Special-purpose action that initializes the SESSION collection using the session token provided as parameter.
Action Group: Non-disruptive
Supported on Coraza: TBI
Example:
# Initialise session variables using the session cookie value SecRule REQUEST_COOKIES:PHPSESSID !^$ \u0026quot;nolog,pass,id:138,setsid:%{REQUEST_COOKIES.PHPSESSID}\u0026quot; Note: After the initialization takes place, the variable SESSION will be available for use in the subsequent rules. This action understands application namespaces (configured using SecWebAppId), and will use one if it is configured.
Setsid takes an individual variable, not a collection. Variables within an action, such as setsid, use the format [collection].[variable] .
setenv # Description: Creates, removes, and updates environment variables that can be accessed by the implementation.
Action Group: Non-disruptive
Examples:
SecRule RESPONSE_HEADERS:/Set-Cookie2?/ \u0026quot;(?i:(j?sessionid|(php)?sessid|(asp|jserv|jw)?session[-_]?(id)?|cf(id|token)|sid))\u0026quot; \u0026quot;phase:3,t:none,pass,id:139,nolog,setvar:tx.sessionid=%{matched_var}\u0026quot; SecRule TX:SESSIONID \u0026quot;!(?i:\\;? ?httponly;?)\u0026quot; \u0026quot;phase:3,id:140,t:none,setenv:httponly_cookie=%{matched_var},pass,log,auditlog,msg:'AppDefect: Missing HttpOnly Cookie Flag.'\u0026quot; Header set Set-Cookie \u0026quot;%{httponly_cookie}e; HTTPOnly\u0026quot; env=httponly_cookie Note : When used in a chain this action will be execute when an individual rule matches and not the entire chain.
setvar # Description: Creates, removes, or updates a variable. Variable names are case-insensitive.
Action Group: Non-disruptive
Examples: To create a variable and set its value to 1 (usually used for setting flags), use: setvar:TX.score
To create a variable and initialize it at the same time, use: setvar:TX.score=10
To remove a variable, prefix the name with an exclamation mark: setvar:!TX.score
To increase or decrease variable value, use + and - characters in front of a numerical value: setvar:TX.score=+5
Example from OWASP CRS:
SecRule REQUEST_FILENAME|ARGS_NAMES|ARGS|XML:/* \u0026quot;\\bsys\\.user_catalog\\b\u0026quot; \\ \u0026quot;phase:2,rev:'2.1.3',capture,t:none,t:urlDecodeUni,t:htmlEntityDecode,t:lowercase,t:replaceComments,t:compressWhiteSpace,ctl:auditLogParts=+E, \\ block,msg:'Blind SQL Injection Attack',id:'959517',tag:'WEB_ATTACK/SQL_INJECTION',tag:'WASCTC/WASC-19',tag:'OWASP_TOP_10/A1',tag:'OWASP_AppSensor/CIE1', \\ tag:'PCI/6.5.2',logdata:'%{TX.0}',severity:'2',setvar:'tx.msg=%{rule.msg}',setvar:tx.sql_injection_score=+%{tx.critical_anomaly_score}, \\ setvar:tx.anomaly_score=+%{tx.critical_anomaly_score},setvar:tx.%{rule.id}-WEB_ATTACK/SQL_INJECTION-%{matched_var_name}=%{tx.0}\u0026quot; Note : When used in a chain this action will be executed when an individual rule matches and not the entire chain.This means that
SecRule REQUEST_FILENAME \u0026quot;@contains /test.php\u0026quot; \u0026quot;chain,id:7,phase:1,t:none,nolog,setvar:tx.auth_attempt=+1\u0026quot; SecRule ARGS_POST:action \u0026quot;@streq login\u0026quot; \u0026quot;t:none\u0026quot; will increment every time that test.php is visited (regardless of the parameters submitted). If the desired goal is to set the variable only if the entire rule matches, it should be included in the last rule of the chain. For instance:
SecRule REQUEST_FILENAME \u0026quot;@streq test.php\u0026quot; \u0026quot;chain,id:7,phase:1,t:none,nolog\u0026quot; SecRule ARGS_POST:action \u0026quot;@streq login\u0026quot; \u0026quot;t:none,setvar:tx.auth_attempt=+1\u0026quot; skip # Description: Skips one or more rules (or chains) on successful match.
Action Group: Flow
Example:
# Require Accept header, but not from access from the localhost SecRule REMOTE_ADDR \u0026quot;^127\\.0\\.0\\.1$\u0026quot; \u0026quot;phase:1,skip:1,id:141\u0026quot; # This rule will be skipped over when REMOTE_ADDR is 127.0.0.1 SecRule \u0026amp;REQUEST_HEADERS:Accept \u0026quot;@eq 0\u0026quot; \u0026quot;phase:1,id:142,deny,msg:'Request Missing an Accept Header'\u0026quot; The skip action works only within the current processing phase and not necessarily in the order in which the rules appear in the configuration file. If you place a phase 2 rule after a phase 1 rule that uses skip, it will not skip over the phase 2 rule. It will skip over the next phase 1 rule that follows it in the phase.
skipAfter # Description: Skips one or more rules (or chains) on a successful match, resuming rule execution with the first rule that follows the rule (or marker created by SecMarker) with the provided ID.
Action Group: Flow
Example: The following rules implement the same logic as the skip example, but using skipAfter:
# Require Accept header, but not from access from the localhost SecRule REMOTE_ADDR \u0026quot;^127\\.0\\.0\\.1$\u0026quot; \u0026quot;phase:1,id:143,skipAfter:IGNORE_LOCALHOST\u0026quot; # This rule will be skipped over when REMOTE_ADDR is 127.0.0.1 SecRule \u0026amp;REQUEST_HEADERS:Accept \u0026quot;@eq 0\u0026quot; \u0026quot;phase:1,deny,id:144,msg:'Request Missing an Accept Header'\u0026quot; SecMarker IGNORE_LOCALHOST Example from the OWASP CRS:
SecMarker BEGIN_HOST_CHECK SecRule \u0026amp;REQUEST_HEADERS:Host \u0026quot;@eq 0\u0026quot; \\ \u0026quot;skipAfter:END_HOST_CHECK,phase:2,rev:'2.1.3',t:none,block,msg:'Request Missing a Host Header',id:'960008',tag:'PROTOCOL_VIOLATION/MISSING_HEADER_HOST',tag:'WASCTC/WASC-21', \\ tag:'OWASP_TOP_10/A7',tag:'PCI/6.5.10',severity:'5',setvar:'tx.msg=%{rule.msg}',setvar:tx.anomaly_score=+%{tx.notice_anomaly_score}, \\ setvar:tx.protocol_violation_score=+%{tx.notice_anomaly_score},setvar:tx.%{rule.id}-PROTOCOL_VIOLATION/MISSING_HEADER-%{matched_var_name}=%{matched_var}\u0026quot; SecRule REQUEST_HEADERS:Host \u0026quot;^$\u0026quot; \\ \u0026quot;phase:2,rev:'2.1.3',t:none,block,msg:'Request Missing a Host Header',id:'960008',tag:'PROTOCOL_VIOLATION/MISSING_HEADER_HOST',tag:'WASCTC/WASC-21',tag:'OWASP_TOP_10/A7', \\ tag:'PCI/6.5.10',severity:'5',setvar:'tx.msg=%{rule.msg}',setvar:tx.anomaly_score=+%{tx.notice_anomaly_score},setvar:tx.protocol_violation_score=+%{tx.notice_anomaly_score}, \\ setvar:tx.%{rule.id}-PROTOCOL_VIOLATION/MISSING_HEADER-%{matched_var_name}=%{matched_var}\u0026quot; SecMarker END_HOST_CHECK The skipAfter action works only within the current processing phase and not necessarily the order in which the rules appear in the configuration file. If you place a phase 2 rule after a phase 1 rule that uses skip, it will not skip over the phase 2 rule. It will skip over the next phase 1 rule that follows it in the phase.
status # Description: Specifies the response status code to use with actions deny and redirect.
Action Group: Data
Example:
# Deny with status 403 SecDefaultAction \u0026quot;phase:1,log,deny,id:145,status:403\u0026quot; t # Description: This action is used to specify the transformation pipeline to use to transform the value of each variable used in the rule before matching.
Action Group: Non-disruptive
Example:
SecRule ARGS \u0026quot;(asfunction|javascript|vbscript|data|mocha|livescript):\u0026quot; \u0026quot;id:146,t:none,t:htmlEntityDecode,t:lowercase,t:removeNulls,t:removeWhitespace\u0026quot; Any transformation functions that you specify in a SecRule will be added to the previous ones specified in SecDefaultAction. It is recommended that you always use t:none in your rules, which prevents them depending on the default configuration.
tag # Description: Assigns a tag (category) to a rule or a chain.
Action Group: Meta-data
Example:
SecRule REQUEST_FILENAME|ARGS_NAMES|ARGS|XML:/* \u0026quot;\\bgetparentfolder\\b\u0026quot; \\ \u0026quot;phase:2,rev:'2.1.3',capture,t:none,t:htmlEntityDecode,t:compressWhiteSpace,t:lowercase,ctl:auditLogParts=+E,block,msg:'Cross-site Scripting (XSS) Attack',id:'958016',tag:'WEB_ATTACK/XSS',tag:'WASCTC/WASC-8',tag:'WASCTC/WASC-22',tag:'OWASP_TOP_10/A2',tag:'OWASP_AppSensor/IE1',tag:'PCI/6.5.1',logdata:'% \\ {TX.0}',severity:'2',setvar:'tx.msg=%{rule.msg}',setvar:tx.xss_score=+%{tx.critical_anomaly_score},setvar:tx.anomaly_score=+%{tx.critical_anomaly_score},setvar:tx.%{rule.id}-WEB_ATTACK/XSS-%{matched_var_name}=%{tx.0}\u0026quot; The tag information appears along with other rule metadata. The purpose of the tagging mechanism to allow easy automated categorization of events. Multiple tags can be specified on the same rule. Use forward slashes to create a hierarchy of categories (as in the example). Tag support Macro Expansions
ver # Description: Specifies the rule set version.
Action Group: Meta-data
Example:
SecRule REQUEST_FILENAME|ARGS_NAMES|ARGS|XML:/* \u0026quot;\\bgetparentfolder\\b\u0026quot; \\ \u0026quot;phase:2,ver:'CRS/2.2.4,capture,t:none,t:htmlEntityDecode,t:compressWhiteSpace,t:lowercase,ctl:auditLogParts=+E,block,msg:'Cross-site Scripting (XSS) Attack',id:'958016',tag:'WEB_ATTACK/XSS',tag:'WASCTC/WASC-8',tag:'WASCTC/WASC-22',tag:'OWASP_TOP_10/A2',tag:'OWASP_AppSensor/IE1',tag:'PCI/6.5.1',logdata:'% \\ {TX.0}',severity:'2',setvar:'tx.msg=%{rule.msg}',setvar:tx.xss_score=+%{tx.critical_anomaly_score},setvar:tx.anomaly_score=+%{tx.critical_anomaly_score},setvar:tx.%{rule.id}-WEB_ATTACK/XSS-%{matched_var_name}=%{tx.0}\u0026quot; `}),e.add({id:3,href:"/docs/seclang/execution-flow/",title:"Execution flow",description:"Learn how to control Coraza rules execution flow using special directives and actions.",content:`Phases # Phases are an abstract concept designed to fit most web servers execution flows and give it more oportunities to stop a request.
Phase 1: Request Headers # This phase will process rules with the following variables:
HTTP connection data, like IPs, ports and protocol version URI and GET arguments Request Headers: cookies, content-type and content-length Phase 2: Request Body # This phase will process rules with the following variables:
POST arguments Multipart arguments and files JSON and XML data Raw Request Body Phase 3: Response Headers # This phase will process rules with the following variables:
Response status code Response headers: content-length and content-type Phase 4: Response Body # This phase will process rules with the following variables:
Raw Response body Phase 5: Logging # This phase will evaluate phase 5 rules, save persistent collections and write the log entry. This phase is not disruptive and it may run after the response was sent to the client.
How rules are sorted # Rules are not sorted by id, they are sorted by phase and compilation order. For example:
SecAction \u0026quot;id:1,phase:3,logdata:'first rule',log\u0026quot; SecAction \u0026quot;id:150,phase:2,logdata:'second rule',log\u0026quot; SecAction \u0026quot;id:300,phase:1,logdata:'third rule',log\u0026quot; This will evaluate the rules based on it\u0026rsquo;s phase, not its id, and show the following logdata:
third rule second rule first rule Secmarkers # SecMarker is a directive that creates an abstract rule, without rules, operators and actions, that will only work as a placeholder to tell the transaction under which SecMarker we are.
SecMarker BEGIN_HOST_CHECK SecRule \u0026amp;REQUEST_HEADERS:Host \u0026quot;@eq 0\u0026quot; \u0026quot;phase:1,id:1,pass\u0026quot; SecRule REQUEST_HEADERS:Host \u0026quot;^$\u0026quot; \u0026quot;phase:1,id:2,pass\u0026quot; SecMarker END_HOST_CHECK This will \u0026ldquo;mark\u0026rdquo; rules 1 and 2 as BEGIN_HOST_CHECK, which will be used by skipAfter action to skip the following rules after the \u0026ldquo;SecMark\u0026rdquo; was reached, for example:
SecAction \u0026quot;id:1, phase:1,skipAfter:END_HOST_CHECK\u0026quot; SecMarker BEGIN_HOST_CHECK SecRule \u0026amp;REQUEST_HEADERS:Host \u0026quot;@eq 0\u0026quot; \u0026quot;phase:1,id:2,pass\u0026quot; SecRule REQUEST_HEADERS:Host \u0026quot;^$\u0026quot; \u0026quot;phase:1,id:3,pass\u0026quot; SecMarker END_HOST_CHECK SecAction \u0026quot;id:4,phase:1,pass\u0026quot; In the example above, rules 2 and 3 will be skipped because they are marked as BEGIN_HOST_CHECK and not END_HOST_CHECK as expected by skipAfter.
Other flow controllers # Skip action can also be used to skip the N following rules, for example:
SecAction \u0026quot;id:1,phase:1, skip:1\u0026quot; # The following rule won't be evaluated SecAction \u0026quot;id:2\u0026quot; # This rule will be evaluated SecAction \u0026quot;id:3\u0026quot; `}),e.add({id:4,href:"/docs/seclang/directives/include/",title:"Include",description:"Include and evaluate a file or file pattern.",content:`Include loads a file or a list of files from the filesystem using golang Glob syntax.
Quoting golang documentation:
The syntax of patterns is the same as in Match. The pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is \u0026lsquo;/\u0026rsquo;).
Glob ignores file system errors such as I/O errors reading directories. The only possible returned error is ErrBadPattern, when pattern is malformed.\`
`}),e.add({id:5,href:"/docs/tutorials/introduction/",title:"Introduction",description:"Introduction to Coraza Web Application Firewall. Start protecting your web applications in few steps.",content:`Coraza Web Application Firewall v2 # Welcome to Coraza Web Application Firewall, this project is an enterprise grade, Golang port of ModSecurity, flexible and powerful enough to serve as the baseline for many projects. Prerequisites # Linux distribution (Debian and Centos are recommended, Windows is not supported yet) Golang compiler v1.16+ Migrate from v1 # Rollback SecAuditLog to the legacy syntax (serial/concurrent) Attach an error log handler using waf.SetErrorLogCb(cb) (optional) If you are using @detectXSS and @detectSQLi (CRS) install the plugin github.com/jptosso/coraza-libinjection If you are using @rx with libpcre (CRS) install the plugin github.com/jptosso/coraza-pcre If you are using low level APIs check the complete changelog as most of them were removed Running the tests # Run the go tests:
go test ./... go test -race ./... Coraza v2 differences with v1 # Full internal API refactor, public API has not changed Full audit engine refactor with plugins support New enhanced plugins interface for transformations, actions, body processors and operators Now we are fully compliant with Seclang from modsecurity v2 Many features removed and transformed into plugins: XML processing, PCRE regex, Libinjection (@detectXSS and @detectSQLi) Better debug logging New error logging (like modsecurity) Your first Coraza WAF project # package main import( \u0026quot;fmt\u0026quot; \u0026quot;github.com/coraza-waf/coraza/v2\u0026quot; \u0026quot;github.com/coraza-waf/coraza/v2/seclang\u0026quot; ) func main() { // First we initialize our waf and our seclang parser waf := coraza.NewWaf() parser, _ := seclang.NewParser(waf) // Now we parse our rules if err := parser.FromString(\`SecRule REMOTE_ADDR \u0026quot;@rx .*\u0026quot; \u0026quot;id:1,phase:1,deny,status:403\u0026quot;\`); err != nil { fmt.Println(err) } // Then we create a transaction and assign some variables tx := waf.NewTransaction() tx.ProcessConnection(\u0026quot;127.0.0.1\u0026quot;, 8080, \u0026quot;127.0.0.1\u0026quot;, 12345) // Finally we process the request headers phase, which may return an interruption if it := tx.ProcessRequestHeaders(); it != nil { fmt.Printf(\u0026quot;Transaction was interrupted with status %d\\n\u0026quot;, it.Status) } } Why Coraza WAF? # Philosophy # Simplicity: Anyone should be able to understand and modify Coraza WAF\u0026rsquo;s source code Extensibility: It should be easy to extend Coraza WAF with new functionalities Innovation: Coraza WAF isn\u0026rsquo;t just a ModSecurity port, it must include awesome new functions (in the meantime it\u0026rsquo;s just a port ðŸ˜…) Community: Coraza WAF is a community project and everyone\u0026rsquo;s idea will be heard Plugins roadmap # WASM scripts support Lua script support Integrated DDOS protection and directives with iptables(Or others) integration Integrated bot detection with captcha Open Policy Agent package (OPA) Enhanced data signing features (cookies, forms, etc) OpenAPI enforcement JWT enforcement XML request body processor Libinjection integration (done) Lib PCRE integration (done) Bluemonday policies (maybe) Coraza WAF implementations # Caddy Plugin (Reverse Proxy and Web Server) (Stable) Traefik Plugin (Reverse Proxy and Web Server) (preview) Gin Middleware (Web Framework) (Preview) Buffalo Plugin (Web Framework) (soon) Coraza Server (HAPROXY, REST and GRPC) (experimental) Apache httpd (experimental) Nginx (soon) Coraza C Exports (experimental) Some useful tools # Go FTW: rule testing engine Coraza Playground: rule testing sandbox with web interface Troubleshooting # How to contribute # Contributions are welcome, there are so many TODOs, also functionalities, fixes, bug reports and any help you can provide. Just send your PR.
cd /path/to/coraza egrep -Rin \u0026quot;TODO|FIXME\u0026quot; -R --exclude-dir=vendor * Useful links # Special thanks # Modsecurity team for creating ModSecurity OWASP Coreruleset team for the CRS and their help @fzipi for his support and help @dune73 for the Modsecurity Handbook (The bible for this project) and all of his support Companies using Coraza # Babiel (supporter) About # The name Coraza is trademarked, Coraza is a registered trademark of Juan Pablo Tosso.
Author on Twitter @jptosso Donations # For donations, see Donations site
`}),e.add({id:6,href:"/docs/seclang/operators/",title:"Operators",description:"This section documents the operators currently available in Coraza.",content:`beginsWith # Description: Returns true if the parameter string is found at the beginning of the input. Macro expansion is performed on the parameter string before comparison.
Example:
# Detect request line that does not begin with \u0026quot;GET\u0026quot; SecRule REQUEST_LINE \u0026quot;!@beginsWith GET\u0026quot; \u0026quot;id:149\u0026quot; contains # Description: Returns true if the parameter string is found anywhere in the input. Macro expansion is performed on the parameter string before comparison.
Example:
# Detect \u0026quot;.php\u0026quot; anywhere in the request line SecRule REQUEST_LINE \u0026quot;@contains .php\u0026quot; \u0026quot;id:150\u0026quot; containsWord # Description: Returns true if the parameter string (with word boundaries) is found anywhere in the input. Macro expansion is performed on the parameter string before comparison.
Example:
# Detect \u0026quot;select\u0026quot; anywhere in ARGS SecRule ARGS \u0026quot;@containsWord select\u0026quot; \u0026quot;id:151\u0026quot; Would match on - -1 union select BENCHMARK(2142500,MD5(CHAR(115,113,108,109,97,112))) FROM wp_users WHERE ID=1 and (ascii(substr(user_login,1,1))\u0026amp;0x01=0) from wp_users where ID=1\u0026ndash;
But not on - Your site has a wide selection of computers.
endsWith # Description: Returns true if the parameter string is found at the end of the input. Macro expansion is performed on the parameter string before comparison.
Example:
# Detect request line that does not end with \u0026quot;HTTP/1.1\u0026quot; SecRule REQUEST_LINE \u0026quot;!@endsWith HTTP/1.1\u0026quot; \u0026quot;id:152\u0026quot; fuzzyHash # Description: The fuzzyHash operator uses the ssdeep, which is a program for computing context triggered piecewise hashes (CTPH). Also called fuzzy hashes, CTPH can match inputs that have homologies. Such inputs have sequences of identical bytes in the same order, although bytes in between these sequences may be different in both content and length.
For further information on ssdeep, visit its site: http://ssdeep.sourceforge.net/
Supported: TBI
Example:
SecRule REQUEST_BODY \u0026quot;\\@fuzzyHash /path/to/ssdeep/hashes.txt 6\u0026quot; \u0026quot;id:192372,log,deny\u0026quot; eq # Description: Performs numerical comparison and returns true if the input value is equal to the provided parameter. Macro expansion is performed on the parameter string before comparison.
Example:
# Detect exactly 15 request headers SecRule \u0026amp;REQUEST_HEADERS_NAMES \u0026quot;@eq 15\u0026quot; \u0026quot;id:153\u0026quot; Note: If a value is provided that cannot be converted to an integer (i.e a string) this operator will treat that value as 0.
ge # Description: Performs numerical comparison and returns true if the input value is greater than or equal to the provided parameter. Macro expansion is performed on the parameter string before comparison.
Example:
# Detect 15 or more request headers SecRule \u0026amp;REQUEST_HEADERS_NAMES \u0026quot;@ge 15\u0026quot; \u0026quot;id:154\u0026quot; Note: If a value is provided that cannot be converted to an integer (i.e a string) this operator will treat that value as 0.
geoLookup # Description: Performs a geolocation lookup using the IP address in input against the geolocation database previously configured using SecGeoLookupDb. If the lookup is successful, the obtained information is captured in the GEO collection.
Example: The geoLookup operator matches on success and is thus best used in combination with nolog,pass. If you wish to block on a failed lookup (which may be over the top, depending on how accurate the geolocation database is), the following example demonstrates how best to do it:
# Configure geolocation database SecGeoLookupDb /path/to/GeoLiteCity.dat ... # Lookup IP address SecRule REMOTE_ADDR \u0026quot;@geoLookup\u0026quot; \u0026quot;phase:1,id:155,nolog,pass\u0026quot; # Block IP address for which geolocation failed SecRule \u0026amp;GEO \u0026quot;@eq 0\u0026quot; \u0026quot;phase:1,id:156,deny,msg:'Failed to lookup IP'\u0026quot; See the GEO variable for an example and more information on various fields available. Note: This operator supports the \u0026ldquo;capture\u0026rdquo; action.
gt # Description: Performs numerical comparison and returns true if the input value is greater than the operator parameter. Macro expansion is performed on the parameter string before comparison.
Example:
# Detect more than 15 headers in a request SecRule \u0026amp;REQUEST_HEADERS_NAMES \u0026quot;@gt 15\u0026quot; \u0026quot;id:158\u0026quot; Note: If a value is provided that cannot be converted to an integer (i.e a string) this operator will treat that value as 0.
inspectFile # Description: Executes an external program for every variable in the target list. The contents of the variable is provided to the script as the first parameter on the command line. The program must be specified as the first parameter to the operator. As of version 2.5.0, if the supplied program filename is not absolute, it is treated as relative to the directory in which the configuration file resides. Also as of version 2.5.0, if the filename is determined to be a Lua script (based on its .lua extension), the script will be processed by the internal Lua engine. Internally processed scripts will often run faster (there is no process creation overhead) and have full access to the transaction context of Coraza.
The inspectFile operator was initially designed for file inspection (hence the name), but it can also be used in any situation that requires decision making using external logic.
#!/usr/bin/perl # # runav.pl # Copyright (c) 2004-2011 Trustwave # # This script is an interface between Coraza and its # ability to intercept files being uploaded through the # web server, and ClamAV $CLAMSCAN = \u0026quot;clamscan\u0026quot;; if ($#ARGV != 0) { print \u0026quot;Usage: runav.pl \u0026lt;filename\u0026gt;\\n\u0026quot;; exit; } my ($FILE) = shift @ARGV; $cmd = \u0026quot;$CLAMSCAN --stdout --no-summary $FILE\u0026quot;; $input = \`$cmd\`; $input =~ m/^(.+)/; $error_message = $1; $output = \u0026quot;0 Unable to parse clamscan output [$1]\u0026quot;; if ($error_message =~ m/: Empty file\\.?$/) { $output = \u0026quot;1 empty file\u0026quot;; } elsif ($error_message =~ m/: (.+) ERROR$/) { $output = \u0026quot;0 clamscan: $1\u0026quot;; } elsif ($error_message =~ m/: (.+) FOUND$/) { $output = \u0026quot;0 clamscan: $1\u0026quot;; } elsif ($error_message =~ m/: OK$/) { $output = \u0026quot;1 clamscan: OK\u0026quot;; } print \u0026quot;$output\\n\u0026quot;; Example: Using the runav.pl script:
# Execute external program to validate uploaded files SecRule FILES_TMPNAMES \u0026quot;@inspectFile /path/to/util/runav.pl\u0026quot; \u0026quot;id:159\u0026quot; Note: Coraza will not fill the FILES_TMPNAMES variable unless SecTmpSaveUploadedFiles directive is On, or the SecUploadKeepFiles directive is set to RelevantOnly.
Note: Use @inspectFile with caution. It may not be safe to use @inspectFile with variables other than FILES_TMPNAMES. Other variables such as \u0026ldquo;FULL_REQUEST\u0026rdquo; may contains content that force your platform to fork process out of your control, making possible to an attacker to execute code using the same permissions of your web server. For other variables you may want to look at the Lua script engine. This observation was brought to our attention by \u0026ldquo;Gryzli\u0026rdquo;, on our users mailing list.
Reference: http://blog.spiderlabs.com/2010/10/advanced-topic-of-the-week-preventing-malicious-pdf-file-uploads.html
Reference: http://sourceforge.net/p/mod-security/mailman/mod-security-users/?viewmonth=201512
ipMatch # Description: Performs a fast ipv4 or ipv6 match of REMOTE_ADDR variable data. Can handle the following formats:
Full IPv4 Address - 192.168.1.100 Network Block/CIDR Address - 192.168.1.0/24 Full IPv6 Address - 2001:db8:85a3:8d3:1319:8a2e:370:7348 Network Block/CIDR Address - 2001:db8:85a3:8d3:1319:8a2e:370:0/24 Examples:
Individual Address:
SecRule REMOTE_ADDR \u0026quot;@ipMatch 192.168.1.100\u0026quot; \u0026quot;id:161\u0026quot; Multiple Addresses w/network block: SecRule REMOTE_ADDR \u0026quot;@ipMatch 192.168.1.100,192.168.1.50,10.10.50.0/24\u0026quot; \u0026quot;id:162\u0026quot; ipMatchF # short alias for ipMatchFromFile
ipMatchFromFile # Description: Performs a fast ipv4 or ipv6 match of REMOTE_ADDR variable, loading data from a file. Can handle the following formats:
Full IPv4 Address - 192.168.1.100 Network Block/CIDR Address - 192.168.1.0/24 Full IPv6 Address - 2001:db8:85a3:8d3:1319:8a2e:370:7348 Network Block/CIDR Address - 2001:db8:85a3:8d3:1319:8a2e:370:0/24 Examples:
SecRule REMOTE_ADDR \u0026quot;@ipMatchFromFile ips.txt\u0026quot; \u0026quot;id:163\u0026quot; The file ips.txt may contain:
192.168.0.1 172.16.0.0/16 10.0.0.0/8 Note: This operator also supports to load content served by an HTTPS server.
Note: When used with content served by a HTTPS server, the directive SecRemoteRulesFailAction can be used to configure a warning instead of an abort, when the remote content could not be retrieved.
le # Description: Performs numerical comparison and returns true if the input value is less than or equal to the operator parameter. Macro expansion is performed on the parameter string before comparison.
Example:
# Detect 15 or fewer headers in a request SecRule \u0026amp;REQUEST_HEADERS_NAMES \u0026quot;@le 15\u0026quot; \u0026quot;id:164\u0026quot; Note: If a value is provided that cannot be converted to an integer (i.e a string) this operator will treat that value as 0.
lt # Description: Performs numerical comparison and returns true if the input value is less than to the operator parameter. Macro expansion is performed on the parameter string before comparison.
Example:
# Detect fewer than 15 headers in a request SecRule \u0026amp;REQUEST_HEADERS_NAMES \u0026quot;@lt 15\u0026quot; \u0026quot;id:165\u0026quot; Note: If a value is provided that cannot be converted to an integer (i.e a string) this operator will treat that value as 0.
noMatch # Description: Will force the rule to always return false.
pm # Description: Performs a case-insensitive match of the provided phrases against the desired input value. The operator uses a set-based matching algorithm (Aho-Corasick), which means that it will match any number of keywords in parallel. When matching of a large number of keywords is needed, this operator performs much better than a regular expression.
Example:
# Detect suspicious client by looking at the user agent identification SecRule REQUEST_HEADERS:User-Agent \u0026quot;@pm WebZIP WebCopier Webster WebStripper ... SiteSnagger ProWebWalker CheeseBot\u0026quot; \u0026quot;id:166\u0026quot; ðŸ‘‰ This operator supports a snort/suricata content style. ie: "@pm A|42|C|44|F". âš ï¸ This operator does not support macro expansion. Note: This operator supports the \u0026ldquo;capture\u0026rdquo; action.
pmf # Short alias for pmFromFile.
pmFromFile # Description: Performs a case-insensitive match of the provided phrases against the desired input value. The operator uses a set-based matching algorithm (Aho-Corasick), which means that it will match any number of keywords in parallel. When matching of a large number of keywords is needed, this operator performs much better than a regular expression.
This operator is the same as @pm, except that it takes a list of files as arguments. It will match any one of the phrases listed in the file(s) anywhere in the target value.
Example:
# Detect suspicious user agents using the keywords in # the files /path/to/blacklist1 and blacklist2 (the latter # must be placed in the same folder as the configuration file) SecRule REQUEST_HEADERS:User-Agent \u0026quot;@pmFromFile /path/to/blacklist1 blacklist2\u0026quot; \u0026quot;id:167\u0026quot; Notes:
Files must contain exactly one phrase per line. End of line markers (both LF and CRLF) will be stripped from each phrase and any whitespace trimmed from both the beginning and the end. Empty lines and comment lines (those beginning with the # character) will be ignored. To allow easier inclusion of phrase files with rule sets, relative paths may be used to the phrase files. In this case, the path of the file containing the rule is prepended to the phrase file path. The @pm operator phrases do not support metacharacters. Because this operator does not check for boundaries when matching, false positives are possible in some cases. For example, if you want to use @pm for IP address matching, the phrase 1.2.3.4 will potentially match more than one IP address (e.g., it will also match 1.2.3.40 or 1.2.3.41). To avoid the false positives, you can use your own boundaries in phrases. For example, use /1.2.3.4/ instead of just 1.2.3.4. Then, in your rules, also add the boundaries where appropriate. You will find a complete example in the example.
# Prepare custom REMOTE_ADDR variable SecAction \u0026quot;phase:1,id:168,nolog,pass,setvar:tx.REMOTE_ADDR=/%{REMOTE_ADDR}/\u0026quot; # Check if REMOTE_ADDR is blacklisted SecRule TX:REMOTE_ADDR \u0026quot;@pmFromFile blacklist.txt\u0026quot; \u0026quot;phase:1,id:169,deny,msg:'Blacklisted IP address'\u0026quot; The file blacklist.txt may contain:
# ip-blacklist.txt contents: # Note: All IPs must be prefixed/suffixed with \u0026quot;/\u0026quot; as the rules # will add in this character as a boundary to ensure # the entire IP is matched. # SecAction \u0026quot;phase:1,id:170,pass,nolog,setvar:tx.remote_addr='/%{REMOTE_ADDR}/'\u0026quot; /1.2.3.4/ /5.6.7.8/ Note: This operator supports a snort/suricata content style. ie: \u0026ldquo;A|42|C|44|F\u0026rdquo;.
Note II: This operator also supports to load content served by an HTTPS server. However, only one url can be used at a time.
rbl # Description: Looks up the input value in the RBL (real-time block list) given as parameter. The parameter can be an IPv4 address or a hostname.
Example:
SecRule REMOTE_ADDR \u0026quot;@rbl sbl-xbl.spamhaus.org\u0026quot; \u0026quot;phase:1,id:171,t:none,pass,nolog,auditlog,msg:'RBL Match for SPAM Source',tag:'AUTOMATION/MALICIOUS',severity:'2',setvar:'tx.msg=%{rule.msg}',setvar:tx.automation_score=+%{tx.warning_anomaly_score},setvar:tx.anomaly_score=+%{tx.warning_anomaly_score}, \\ setvar:tx.%{rule.id}-AUTOMATION/MALICIOUS-%{matched_var_name}=%{matched_var},setvar:ip.spammer=1,expirevar:ip.spammer=86400,setvar:ip.previous_rbl_check=1,expirevar:ip.previous_rbl_check=86400,skipAfter:END_RBL_CHECK\u0026quot; Note: If the RBL used is dnsbl.httpbl.org (Honeypot Project RBL) then the SecHttpBlKey directive must specify the user\u0026rsquo;s registered API key.
Note: If the RBL used is either multi.uribl.com or zen.spamhaus.org combined RBLs, it is possible to also parse the return codes in the last octet of the DNS response to identify which specific RBL the IP was found in.
Note: This operator supports the \u0026ldquo;capture\u0026rdquo; action.
rsub # Description: Performs regular expression data substitution when applied to either the STREAM_INPUT_BODY or STREAM_OUTPUT_BODY variables. This operator also supports macro expansion. Starting with Coraza 2.7.0 this operator supports the syntax |hex| allowing users to use special chars like \\n \\r
Syntax: @rsub s/regex/str/[id]
Supported: TBI
Examples: Removing HTML Comments from response bodies:
SecStreamOutBodyInspection On SecRule STREAM_OUTPUT_BODY \u0026quot;@rsub s// /\u0026quot; \u0026quot;phase:4,id:172,t:none,nolog,pass\u0026quot; Note: If you plan to manipulate live data by using @rsub with the STREAM_ variables, you must also enable SecContentInjection directive. Regular expressions are handled by the PCRE library http://www.pcre.org. Coraza compiles its regular expressions with the following settings:
The entire input is treated as a single line, even when there are newline characters present. All matches are case-sensitive. If you wish to perform case-insensitive matching, you can either use the lowercase transformation function or force case-insensitive matching by prefixing the regular expression pattern with the (?i) modifier (a PCRE feature; you will find many similar features in the PCRE documentation). Also a flag [d] should be used if you want to escape the regex string chars when use macro expansion. The PCRE_DOTALL and PCRE_DOLLAR_ENDONLY flags are set during compilation, meaning that a single dot will match any character, including the newlines, and a $ end anchor will not match a trailing newline character. Regular expressions are a very powerful tool. You are strongly advised to read the PCRE documentation to get acquainted with its features.
Note: This operator supports the \u0026ldquo;capture\u0026rdquo; action.
rx # Description: Performs a regular expression match of the pattern provided as parameter. This is the default operator; the rules that do not explicitly specify an operator default to @rx.
Examples:
# Detect Nikto SecRule REQUEST_HEADERS:User-Agent \u0026quot;@rx nikto\u0026quot; phase:1,id:173,t:lowercase SecRule REQUEST_HEADERS:User-Agent \u0026quot;@rx (?i)nikto\u0026quot; phase:1,id:174,t:none # Detect Nikto with a case-insensitive pattern # Detect Nikto with a case-insensitive pattern SecRule REQUEST_HEADERS:User-Agent \u0026quot;(?i)nikto\u0026quot; \u0026quot;id:175\u0026quot; Regular expressions are handled by the RE2. Coraza compiles its regular expressions with the following settings:
The entire input is treated as a single line, even when there are newline characters present. All matches are case-sensitive. If you wish to perform case-insensitive matching, you can either use the lowercase transformation function or force case-insensitive matching by prefixing the regular expression pattern with the (?i) modifier (a PCRE feature; you will find many similar features in the PCRE documentation). A single dot will match any character, including the newlines, and a $ end anchor will not match a trailing newline character. Regular expressions are a very powerful tool. You are strongly advised to read the PCRE documentation to get acquainted with its features.
Note: This operator supports the \u0026ldquo;capture\u0026rdquo; action.
streq # Description: Performs a string comparison and returns true if the parameter string is identical to the input string. Macro expansion is performed on the parameter string before comparison.
Example:
# Detect request parameters \u0026quot;foo\u0026quot; that do not # contain \u0026quot;bar\u0026quot;, exactly. SecRule ARGS:foo \u0026quot;!@streq bar\u0026quot; \u0026quot;id:176\u0026quot; strmatch # Description: Performs a string match of the provided word against the desired input value. The operator uses the pattern matching Boyer-Moore-Horspool algorithm, which means that it is a single pattern matching operator. This operator performs much better than a regular expression.
Example:
# Detect suspicious client by looking at the user agent identification SecRule REQUEST_HEADERS:User-Agent \u0026quot;@strmatch WebZIP\u0026quot; \u0026quot;id:177\u0026quot; Note: Starting on Coraza v2.6.0 this operator supports a snort/suricata content style. ie: \u0026ldquo;@strmatch A|42|C|44|F\u0026rdquo;. unconditionalMatch
Description: Will force the rule to always return true. This is similar to SecAction however all actions that occur as a result of a rule matching will fire such as the setting of MATCHED_VAR. This can also be part a chained rule.
Example:
SecRule REMOTE_ADDR \u0026quot;@unconditionalMatch\u0026quot; \u0026quot;id:1000,phase:1,pass,nolog,t:hexEncode,setvar:TX.ip_hash=%{MATCHED_VAR}\u0026quot; validateByteRange # Description: Validates that the byte values used in input fall into the range specified by the operator parameter. This operator matches on an input value that contains bytes that are not in the specified range.
Example:
# Enforce very strict byte range for request parameters (only # works for the applications that do not use the languages other # than English). SecRule ARGS \u0026quot;@validateByteRange 10, 13, 32-126\u0026quot; \u0026quot;id:178\u0026quot; The validateByteRange is most useful when used to detect the presence of NUL bytes, which donâ€™t have a legitimate use, but which are often used as an evasion technique.
# Do not allow NUL bytes SecRule ARGS \u0026quot;@validateByteRange 1-255\u0026quot; \u0026quot;id:179\u0026quot; Note: You can force requests to consist only of bytes from a certain byte range. This can be useful to avoid stack overflow attacks (since they usually contain \u0026ldquo;random\u0026rdquo; binary content). Default range values are 0 and 255, i.e. all byte values are allowed. This directive does not check byte range in a POST payload when multipart/form-data encoding (file upload) is used. Doing so would prevent binary files from being uploaded. However, after the parameters are extracted from such request they are checked for a valid range.
validateHash # Description: Validates REQUEST_URI that contains data protected by the hash engine.
Supported: TBI
Example:
# Validates requested URI that matches a regular expression. SecRule REQUEST_URI \u0026quot;@validatehash \u0026quot;product_info|product_list\u0026quot; \u0026quot;phase:1,deny,id:123456\u0026quot; validateUrlEncoding # Description: Validates the URL-encoded characters in the provided input string.
Example:
# Validate URL-encoded characters in the request URI SecRule REQUEST_URI_RAW \u0026quot;@validateUrlEncoding\u0026quot; \u0026quot;id:192\u0026quot; Coraza will automatically decode the URL-encoded characters in request parameters, which means that there is little sense in applying the @validateUrlEncoding operator to them â€”that is, unless you know that some of the request parameters were URL-encoded more than once. Use this operator against raw input, or against the input that you know is URL-encoded. For example, some applications will URL-encode cookies, although thatâ€™s not in the standard. Because it is not in the standard, Coraza will neither validate nor decode such encodings.
validateUtf8Encoding # Description: Check whether the input is a valid UTF-8 string.
Example:
# Make sure all request parameters contain only valid UTF-8 SecRule ARGS \u0026quot;@validateUtf8Encoding\u0026quot; \u0026quot;id:193\u0026quot; The @validateUtf8Encoding operator detects the following problems:
Not enough bytes : UTF-8 supports two-, three-, four-, five-, and six-byte encodings. Coraza will locate cases when one or more bytes is/are missing from a character. Invalid characters : The two most significant bits in most characters should be fixed to 0x80. Some attack techniques use different values as an evasion technique. Overlong characters : ASCII characters are mapped directly into UTF-8, which means that an ASCII character is one UTF-8 character at the same time. However, in UTF-8 many ASCII characters can also be encoded with two, three, four, five, and six bytes. This is no longer legal in the newer versions of Unicode, but many older implementations still support it. The use of overlong UTF-8 characters is common for evasion. Notes :
Most, but not all applications use UTF-8. If you are dealing with an application that does, validating that all request parameters are valid UTF-8 strings is a great way to prevent a number of evasion techniques that use the assorted UTF-8 weaknesses. False positives are likely if you use this operator in an application that does not use UTF-8. Many web servers will also allow UTF-8 in request URIs. If yours does, you can verify the request URI using @validateUtf8Encoding. verifyCC # Description: Detects credit card numbers in input. This operator will first use the supplied regular expression to perform an initial match, following up with the Luhn algorithm calculation to minimize false positives.
Supported on Coraza: TBI
Example:
# Detect credit card numbers in parameters and # prevent them from being logged to audit log SecRule ARGS \u0026quot;@verifyCC \\d{13,16}\u0026quot; \u0026quot;phase:2,id:194,nolog,pass,msg:'Potential credit card number',sanitiseMatched\u0026quot; Note: This operator supports the \u0026ldquo;capture\u0026rdquo; action.
within # Description: Returns true if the input value (the needle) is found anywhere within the @within parameter (the haystack). Macro expansion is performed on the parameter string before comparison.
Example:
# Detect request methods other than GET, POST and HEAD SecRule REQUEST_METHOD \u0026quot;!@within GET,POST,HEAD\u0026quot; Note: There are no delimiters for this operator, it is therefore often necessary to artificially impose some; this can be done using setvar. For instance in the example below, without the imposed delimiters (of \u0026lsquo;/\u0026rsquo;) this rule would also match on the \u0026lsquo;range\u0026rsquo; header (along with many other combinations), since \u0026lsquo;range\u0026rsquo; is within the provided parameter. With the imposed delimiters, the rule would check for \u0026lsquo;/range/\u0026rsquo; when the range header is provided, and therefore would not match since \u0026lsquo;/range/ is not part of the @within parameter.
SecRule REQUEST_HEADERS_NAMES \u0026quot;@rx ^.*$\u0026quot; \\ \u0026quot;chain,\\ id:1,\\ block,\\ t:lowercase,\\ setvar:'tx.header_name=/%{tx.0}/'\u0026quot; SecRule TX:header_name \u0026quot;@within /proxy/ /lock-token/ /content-range/ /translate/ /if/\u0026quot; \u0026quot;t:none\u0026quot; `}),e.add({id:7,href:"/docs/seclang/directives/secaction/",title:"SecAction",description:"Unconditionally processes the action list it receives as the first and only parameter. The syntax of the parameter is identical to that of the third parameter of SecRule.",content:`This directive is commonly used to set variables and initialize persistent collections using the initcol action. For example:
SecAction \u0026quot;nolog,phase:1,initcol:RESOURCE=%{REQUEST_FILENAME}\u0026quot; `}),e.add({id:8,href:"/docs/seclang/directives/secargumentseparator/",title:"SecArgumentSeparator",description:"Specifies which character to use as the separator for application/x-www-form- urlencoded content.",content:`This directive is needed if a backend web application is using a nonstandard argument separator. Applications are sometimes (very rarely) written to use a semicolon separator. You should not change the default setting unless you establish that the application you are working with requires a different separator. If this directive is not set properly for each web application, then Coraza will not be able to parse the arguments appropriately and the effectiveness of the rule matching will be significantly decreased.
`}),e.add({id:9,href:"/docs/seclang/directives/secauditengine/",title:"SecAuditEngine",description:"Configures the audit logging engine.",content:`The SecAuditEngine directive is used to configure the audit engine, which logs complete transactions. Coraza is currently able to log most, but not all transactions. Transactions involving errors (e.g., 400 and 404 transactions) use a different execution path, which Coraza does not support.
The possible values for the audit log engine are as follows:
On: log all transactions Off: do not log any transactions RelevantOnly: only the log transactions that have triggered a warning or an error, or have a status code that is considered to be relevant (as determined by the SecAuditLogRelevantStatus directive) Note : If you need to change the audit log engine configuration on a per-transaction basis (e.g., in response to some transaction data), use the ctl action. The following example demonstrates how SecAuditEngine is used:
SecAuditEngine RelevantOnly SecAuditLog logs/audit/audit.log SecAuditLogParts ABCFHZ SecAuditLogType concurrent SecAuditLogStorageDir logs/audit SecAuditLogRelevantStatus ^(?:5|4(?!04)) `}),e.add({id:10,href:"/docs/seclang/directives/secauditlogparts/",title:"SecAuditEngine",description:"Defines which parts of each transaction are going to be recorded in the audit log. Each part is assigned a single letter; when a letter appears in the list then the equivalent part will be recorded. See below for the list of all parts.",content:`The format of the audit log format is documented in detail in the logging page.
Available audit log parts:
A: Audit log header (mandatory). B: Request headers. C: Request body (present only if the request body exists and Coraza is configured to intercept it. This would require SecRequestBodyAccess to be set to on). D: Reserved for intermediary response headers; not implemented yet. E: Intermediary response body (present only if Coraza is configured to intercept response bodies, and if the audit log engine is configured to record it. Intercepting response bodies requires SecResponseBodyAccess to be enabled). Intermediary response body is the same as the actual response body unless Coraza intercepts the intermediary response body, in which case the actual response body will contain the error message (either the Apache default error message, - orthe ErrorDocument page). F: Final response headers (excluding the Date and Server headers, which are always added by Apache in the late stage of content delivery). G: Reserved for the actual response body; not implemented yet. H: Audit log trailer. I: This part is a replacement for part C. It will log the same data as C in all cases except when multipart/form-data encoding in used. In this case, it will log a fake application/x-www-form-urlencoded body that contains the information about parameters but not about the files. This is handy if you donâ€™t want to have (often large) files stored in your audit logs. J: This part contains information about the files uploaded using multipart/form-data encoding. K: This part contains a full list of every rule that matched (one per line) in the order they were matched. The rules are fully qualified and will thus show inherited actions and default operators. Z: Final boundary, signifies the end of the entry (mandatory). `}),e.add({id:11,href:"/docs/seclang/directives/secauditlog/",title:"SecAuditLog",description:"Defines the path to the main audit log file (serial logging format) or the concurrent logging index file (concurrent logging format). When used in combination with mlogc (only possible with concurrent logging), this directive defines the mlogc location and command line.",content:` ðŸ‘‰ Writing to programs using pipe (|) is not implemented yet. SecAuditLog \u0026quot;|/path/to/mlogc /path/to/mlogc.conf\u0026quot; Note : This audit log file is opened on startup when the server typically still runs as root. You should not allow non-root users to have write privileges for this file or for the directory.
`}),e.add({id:12,href:"/docs/seclang/directives/secauditlogrelevantstatus/",title:"SecAuditLogRelevantStatus",description:"Configures which response status code is to be considered relevant for the purpose of audit logging.",content:`Example Usage: SecAuditLogRelevantStatus \u0026quot;^(?:5|40[1235])\u0026quot;
Dependencies/Notes: Must have SecAuditEngine set to RelevantOnly. Additionally, the auditlog action is present by default in rules, this will make the engine bypass the SecAuditLogRelevantStatus and send rule matches to the audit log regardless of status. You must specify noauditlog in the rules manually or set it in SecDefaultAction.
The main purpose of this directive is to allow you to configure audit logging for only the transactions that have the status code that matches the supplied regular expression. The example provided would log all 5xx and 4xx level status codes, except for 404s. Although you could achieve the same effect with a rule in phase 5, SecAuditLogRelevantStatus is sometimes better, because it continues to work even when SecRuleEngine is disabled.
`}),e.add({id:13,href:"/docs/seclang/directives/secdebuglog/",title:"SecDebugLog",description:"Path to the Coraza debug log file.",content:`Logs will be written to this file. Make sure the process user has write access to the directory.
`}),e.add({id:14,href:"/docs/seclang/directives/secdebugloglevel/",title:"SecDebugLogLevel",description:" Configures the verboseness of the debug log data.",content:`Depending on the implementation, errors ranging from 1 to 2 might be directly logged to the connector error log. For example, level 2 (error) logs will be written to caddy server error logs.
The possible values for the debug log level are:
0: Fatal 1: Panic 2: Error 3: Warning 4: details of how transactions are handled 5: log everything, including very detailed debugging information All levels over 5 will be considered as 5.
`}),e.add({id:15,href:"/docs/seclang/directives/secdefaultaction/",title:"SecDefaultAction",description:"Defines the default list of actions, which will be inherited by the rules in the same configuration context.",content:`Every rule following a previous SecDefaultAction directive in the same configuration context will inherit its settings unless more specific actions are used.
Rulesets like OWASP Core Ruleset uses this to define operation modes:
You can set the default disruptive action to block for phases 1 and 2 and you can force a phase 3 rule to be disrupted if the thread score is high. You can set the default disruptive action to deny and each risky rule will interrupt the connection. **Important:**Every SecDefaultAction directive must specify a disruptive action and a processing phase and cannot contain metadata actions.
`}),e.add({id:16,href:"/docs/seclang/directives/secmarker/",title:"SecMarker",description:"Adds a fixed rule marker that can be used as a target in a skipAfter action. A SecMarker directive essentially creates a rule that does nothing and whose only purpose is to carry the given ID.",content:"The value can be either a number or a text string. The SecMarker directive is available to allow you to choose the best way to implement a skip-over. Here is an example used from the Core Rule Set:\nSecMarker BEGIN_HOST_CHECK SecRule \u0026amp;REQUEST_HEADERS:Host \u0026quot;@eq 0\u0026quot; \\ \u0026quot;id:'960008',skipAfter:END_HOST_CHECK,phase:2,rev:'2.1.1',\\ t:none,block,msg:'Request Missing a Host Header',\\ tag:'PROTOCOL_VIOLATION/MISSING_HEADER_HOST',tag:'WASCTC/WASC-21',\\ tag:'OWASP_TOP_10/A7',tag:'PCI/6.5.10',\\ severity:'5',setvar:'tx.msg=%{rule.msg}',setvar:tx.anomaly_score=+%{tx.notice_anomaly_score},\\ setvar:tx.protocol_violation_score=+%{tx.notice_anomaly_score},\\ setvar:tx.%{rule.id}-PROTOCOL_VIOLATION/MISSING_HEADER-%{matched_var_name}=%{matched_var}\u0026quot; SecRule REQUEST_HEADERS:Host \u0026quot;^$\u0026quot; \\ \u0026quot;id:'960008',phase:2,rev:'2.1.1',t:none,block,msg:'Request Missing a Host Header',\\ tag:'PROTOCOL_VIOLATION/MISSING_HEADER_HOST',tag:'WASCTC/WASC-21',\\ tag:'OWASP_TOP_10/A7',tag:'PCI/6.5.10',severity:'5',\\ setvar:'tx.msg=%{rule.msg}',setvar:tx.anomaly_score=+%{tx.notice_anomaly_score},\\ setvar:tx.protocol_violation_score=+%{tx.notice_anomaly_score},\\ setvar:tx.%{rule.id}-PROTOCOL_VIOLATION/MISSING_HEADER-%{matched_var_name}=%{matched_var}\u0026quot; SecMarker END_HOST_CHECK "}),e.add({id:17,href:"/docs/seclang/directives/secrequestbodyaccess/",title:"SecRequestBodyAccess",description:"Configures whether request bodies will be buffered and processed by Coraza.",content:`This directive is required if you want to inspect the data transported request bodies (e.g., POST parameters). Request buffering is also required in order to make reliable blocking possible. The possible values are:
On: buffer request bodies Off: do not buffer request bodies `}),e.add({id:18,href:"/docs/seclang/directives/secrequestbodyinmemorylimit/",title:"SecRequestBodyInMemoryLimit",description:"Configures the maximum request body size that Coraza will store in memory.",content:`When a multipart/form-data request is being processed, once the in-memory limit is reached, the request body will start to be streamed into a temporary file on disk.
ðŸ‘‰ If a tinygo implementation is not capable of writing files, this feature will be disabled. `}),e.add({id:19,href:"/docs/seclang/directives/secrequestbodylimit/",title:"SecRequestBodyLimit",description:"Configures the maximum request body size Coraza will accept for buffering.",content:`Anything over the limit will be rejected with status code 413 (Request Entity Too Large). There is a hard limit of 1 GB.
`}),e.add({id:20,href:"/docs/seclang/directives/secrequestbodynolimit/",title:"SecRequestBodyNoFilesLimit",description:"Configures the maximum request body size Coraza will accept for buffering, excluding the size of any files being transported in the request. This directive is useful to reduce susceptibility to DoS attacks when someone is sending request bodies of very large sizes. Web applications that require file uploads must configure SecRequestBodyLimit to a high value, but because large files are streamed to disk, file uploads will not increase memory consumption. However, itâ€™s still possible for someone to take advantage of a large request body limit and send non-upload requests with large body sizes. This directive eliminates that loophole.",content:`Generally speaking, the default value is not small enough. For most applications, you should be able to reduce it down to 128 KB or lower. Anything over the limit will be rejected with status code 413 (Request Entity Too Large). There is a hard limit of 1 GB.
`}),e.add({id:21,href:"/docs/seclang/transformations/",title:"Transformations",description:"Transformation functions are used to alter input data before it is used in matching.",content:`In the following example, the request parameter values are converted to lowercase before matching:
SecRule ARGS \u0026quot;xp_cmdshell\u0026quot; \u0026quot;t:lowercase,id:91\u0026quot; Multiple transformation actions can be used in the same rule, forming a transformation pipeline. The transformations will be performed in the order in which they appear in the rule.
In most cases, the order in which transformations are performed is very important. In the following example, a series of transformation functions is performed to counter evasion. Performing the transformations in any other order would allow a skillful attacker to evade detection:
SecRule ARGS \u0026quot;(asfunction|javascript|vbscript|data|mocha|livescript):\u0026quot; \u0026quot;id:92,t:none,t:htmlEntityDecode,t:lowercase,t:removeNulls,t:removeWhitespace\u0026quot; ðŸ‘‰ Warning : It is currently possible to use SecDefaultAction to specify a default list of transformation functions, which will be applied to all rules that follow the SecDefaultAction directive. However, this practice is not recommended, because it means that mistakes are very easy to make. It is recommended that you always specify the transformation functions that are needed by a particular rule, starting the list with t:none (which clears the possibly inherited transformation functions). The remainder of this section documents the transformation functions currently available in Coraza.
base64Decode # Decodes a Base64-encoded string.
SecRule REQUEST_HEADERS:Authorization \u0026quot;^Basic ([a-zA-Z0-9]+=*)$\u0026quot; \u0026quot;phase:1,id:93,capture,chain,logdata:%{TX.1}\u0026quot; SecRule TX:1 ^(\\w+): t:base64Decode,capture,chain SecRule TX:1 ^(admin|root|backup)$ Note : Be careful when applying base64Decode with other transformations. The order of your transformation matters in this case as certain transformations may change or invalidate the base64 encoded string prior to being decoded (i.e t:lowercase, etc). This of course means that it is also very difficult to write a single rule that checks for a base64decoded value OR an unencoded value with transformations, it is best to write two rules in this situation. sqlHexDecode Decode sql hex data. Example (0x414243) will be decoded to (ABC).
base64DecodeExt # Decodes a Base64-encoded string. Unlike base64Decode, this version uses a forgiving implementation, which ignores invalid characters.
See blog post on Base64Decoding evasion issues on PHP sites - http://blog.spiderlabs.com/2010/04/impedance-mismatch-and-base64.html
base64Encode # Encodes input string using Base64 encoding.
cmdLine # In Windows and Unix, commands may be escaped by different means, such as:
c^ommand /c \u0026hellip; \u0026ldquo;command\u0026rdquo; /c \u0026hellip; command,/c \u0026hellip; backslash in the middle of a Unix command The cmdLine transformation function avoids this problem by manipulating the variable contend in the following ways:
deleting all backslashes [] deleting all double quotes [\u0026quot;] deleting all single quotes ['] deleting all carets [^] deleting spaces before a slash / deleting spaces before an open parentesis [(] replacing all commas [,] and semicolon [;] into a space replacing all multiple spaces (including tab, newline, etc.) into one space transform all characters to lowercase Example Usage:
SecRule ARGS \u0026quot;(?:command(?:.com)?|cmd(?:.exe)?)(?:/.*)?/[ck]\u0026quot; \u0026quot;phase:2,id:94,t:none, t:cmdLine\u0026quot; compressWhitespace # Converts any of the whitespace characters (0x20, \\f, \\t, \\n, \\r, \\v, 0xa0) to spaces (ASCII 0x20), compressing multiple consecutive space characters into one.
cssDecode # Decodes characters encoded using the CSS 2.x escape rules syndata.html#characters. This function uses only up to two bytes in the decoding process, meaning that it is useful to uncover ASCII characters encoded using CSS encoding (that wouldnâ€™t normally be encoded), or to counter evasion, which is a combination of a backslash and non-hexadecimal characters (e.g., ja\\vascript is equivalent to javascript).
escapeSeqDecode # Decodes ANSI C escape sequences: \\a, \\b, \\f, \\n, \\r, \\t, \\v, \\, ?, ', \u0026quot;, \\xHH (hexadecimal), \\0OOO (octal). Invalid encodings are left in the output.
hexDecode # Decodes a string that has been encoded using the same algorithm as the one used in hexEncode (see following entry).
hexEncode # Encodes string (possibly containing binary characters) by replacing each input byte with two hexadecimal characters. For example, xyz is encoded as 78797a.
htmlEntityDecode # Decodes the characters encoded as HTML entities. The following variants are supported:
HH and HH; (where H is any hexadecimal number) DDD and DDD; (where D is any decimal number) \u0026amp;quotand\u0026quot; \u0026amp;nbspand \u0026amp;ltand\u0026lt; \u0026amp;gtand\u0026gt; This function always converts one HTML entity into one byte, possibly resulting in a loss of information (if the entity refers to a character that cannot be represented with the single byte). It is thus useful to uncover bytes that would otherwise not need to be encoded, but it cannot do anything meaningful with the characters from the range above 0xff.
jsDecode # Decodes JavaScript escape sequences. If a \\uHHHH code is in the range of FF01-FF5E (the full width ASCII codes), then the higher byte is used to detect and adjust the lower byte. Otherwise, only the lower byte will be used and the higher byte zeroed (leading to possible loss of information).
length # Looks up the length of the input string in bytes, placing it (as string) in output. For example, if it gets ABCDE on input, this transformation function will return 5 on output.
lowercase # Converts all characters to lowercase using the current C locale.
md5 # Calculates an MD5 hash from the data in input. The computed hash is in a raw binary form and may need encoded into text to be printed (or logged). Hash functions are commonly used in combination with hexEncode (for example: t:md5,t:hexEncode).
none # Not an actual transformation function, but an instruction to Coraza to remove all transformation functions associated with the current rule.
normalizePath # Removes multiple slashes, directory self-references, and directory back-references (except when at the beginning of the input) from input string.
normalizePathWin # Same as normalizePath, but first converts backslash characters to forward slashes.
parityEven7bit # Calculates even parity of 7-bit data replacing the 8th bit of each target byte with the calculated parity bit.
parityOdd7bit # Calculates odd parity of 7-bit data replacing the 8th bit of each target byte with the calculated parity bit.
parityZero7bit # Calculates zero parity of 7-bit data replacing the 8th bit of each target byte with a zero-parity bit, which allows inspection of even/odd parity 7-bit data as ASCII7 data.
removeNulls # Removes all NUL bytes from input.
removeWhitespace # Removes all whitespace characters from input.
replaceComments # Replaces each occurrence of a C-style comment (/\u0026hellip;/) with a single space (multiple consecutive occurrences of which will not be compressed). Unterminated comments will also be replaced with a space (ASCII 0x20). However, a standalone termination of a comment (*/) will not be acted upon.
removeCommentsChar # Removes common comments chars (/,/, \u0026ndash;, #).
removeComments # Removes each occurrence of comment (/\u0026hellip;/, \u0026ndash;, #). Multiple consecutive occurrences of which will not be compressed.
Note : This transformation is known to be unreliable, might cause some unexpected behaviour and could be deprecated soon in a future release. Refer to issue #1207 for further information..
replaceNulls # Replaces NUL bytes in input with space characters (ASCII 0x20).
urlDecode # Decodes a URL-encoded input string. Invalid encodings (i.e., the ones that use non-hexadecimal characters, or the ones that are at the end of string and have one or two bytes missing) are not converted, but no error is raised. To detect invalid encodings, use the @validateUrlEncoding operator on the input data first. The transformation function should not be used against variables that have already been URL-decoded (such as request parameters) unless it is your intention to perform URL decoding twice!
uppercase # Converts all characters to uppercase using the current C locale.
urlDecodeUni # Like urlDecode, but with support for the Microsoft-specific %u encoding. If the code is in the range of FF01-FF5E (the full-width ASCII codes), then the higher byte is used to detect and adjust the lower byte. Otherwise, only the lower byte will be used and the higher byte zeroed.
urlEncode # Encodes input string using URL encoding.
utf8toUnicode # Converts all UTF-8 characters sequences to Unicode. This help input normalization specially for non-english languages minimizing false-positives and false-negatives.
sha1 # Calculates a SHA1 hash from the input string. The computed hash is in a raw binary form and may need encoded into text to be printed (or logged). Hash functions are commonly used in combination with hexEncode (for example, t:sha1,t:hexEncode).
trimLeft # Removes whitespace from the left side of the input string.
trimRight # Removes whitespace from the right side of the input string.
trim # Removes whitespace from both the left and right sides of the input string.
`}),e.add({id:22,href:"/docs/seclang/variables/",title:"Variables",description:`Variables are embedded in the core for performance reasons, which means they cannot be programmatically created. For that reason, there is a set of predefined variables that are available to plugin developers.
GRAPHQL JWT EXTRA ARGS # ARGS is a collection and can be used on its own (means all arguments including the POST Payload), with a static parameter (matches arguments with that name), or with a regular expression (matches all arguments with name that matches the regular expression).`,content:`Variables are embedded in the core for performance reasons, which means they cannot be programmatically created. For that reason, there is a set of predefined variables that are available to plugin developers.
GRAPHQL JWT EXTRA ARGS # ARGS is a collection and can be used on its own (means all arguments including the POST Payload), with a static parameter (matches arguments with that name), or with a regular expression (matches all arguments with name that matches the regular expression). To look at only the query string or body arguments, see the ARGS_GET and ARGS_POST collections.
Some variables are actually collections, which are expanded into more variables at runtime. The following example will examine all request arguments:
SecRule ARGS dirty \u0026quot;id:7\u0026quot; Sometimes, however, you will want to look only at parts of a collection. This can be achieved with the help of the selection operator(colon). The following example will only look at the arguments named p (do note that, in general, requests can contain multiple arguments with the same name):
SecRule ARGS:p dirty \u0026quot;id:8\u0026quot; It is also possible to specify exclusions. The following will examine all request arguments for the word dirty, except the ones named z (again, there can be zero or more arguments named z):
SecRule ARGS|!ARGS:z dirty \u0026quot;id:9\u0026quot; There is a special operator that allows you to count how many variables there are in a collection. The following rule will trigger if there is more than zero arguments in the request (ignore the second parameter for the time being):
SecRule \u0026amp;ARGS !^0$ \u0026quot;id:10\u0026quot; And sometimes you need to look at an array of parameters, each with a slightly different name. In this case you can specify a regular expression in the selection operator itself. The following rule will look into all arguments whose names begin with id_:
SecRule ARGS:/^id_/ dirty \u0026quot;id:11\u0026quot; Note : Using ARGS:p will not result in any invocations against the operator if argument p does not exist.
ARGS_COMBINED_SIZE # Contains the combined size of all request parameters. Files are excluded from the calculation. This variable can be useful, for example, to create a rule to ensure that the total size of the argument data is below a certain threshold. The following rule detects a request whose parameters are more than 2500 bytes long:
SecRule ARGS_COMBINED_SIZE \u0026quot;@gt 2500\u0026quot; \u0026quot;id:12\u0026quot; ARGS_GET # ARGS_GET is similar to ARGS, but contains only query string parameters.
ARGS_GET_NAMES # ARGS_GET_NAMES is similar to ARGS_NAMES, but contains only the names of query string parameters.
ARGS_NAMES # Contains all request parameter names. You can search for specific parameter names that you want to inspect. In a positive policy scenario, you can also whitelist (using an inverted rule with the exclamation mark) only the authorized argument names. This example rule allows only two argument names: p and a:
SecRule ARGS_NAMES \u0026quot;!^(p|a)$\u0026quot; \u0026quot;id:13\u0026quot; ARGS_POST # ARGS_POST is similar to ARGS, but only contains arguments from the POST body.
ARGS_POST_NAMES # ARGS_POST_NAMES is similar to ARGS_NAMES, but contains only the names of request body parameters.
AUTH_TYPE # This variable holds the authentication method used to validate a user, if any of the methods built into HTTP are used. In a reverse-proxy deployment, this information will not be available if the authentication is handled in the backend web server.
SecRule AUTH_TYPE \u0026quot;Basic\u0026quot; \u0026quot;id:14\u0026quot; DURATION # Contains the number of microseconds elapsed since the beginning of the current transaction.
ENV # Collection that provides access to environment variables set by Coraza or other server modules. Requires a single parameter to specify the name of the desired variable.
# Set environment variable SecRule REQUEST_FILENAME \u0026quot;printenv\u0026quot; \\ \u0026quot;phase:2,id:15,pass,setenv:tag=suspicious\u0026quot; # Inspect environment variable SecRule ENV:tag \u0026quot;suspicious\u0026quot; \u0026quot;id:16\u0026quot; # Reading an environment variable from other Apache module (mod_ssl) SecRule TX:ANOMALY_SCORE \u0026quot;@gt 0\u0026quot; \u0026quot;phase:5,id:16,msg:'%{env.ssl_cipher}'\u0026quot; Note : Use setenv to set environment variables to be accessed by Apache.
FILES # Contains a collection of original file names (as they were called on the remote userâ€™s filesys- tem). Available only on inspected multipart/form-data requests.
SecRule FILES \u0026quot;@rx \\.conf$\u0026quot; \u0026quot;id:17\u0026quot; Note : Only available if files were extracted from the request body.
FILES_COMBINED_SIZE # Contains the total size of the files transported in request body. Available only on inspected multipart/form-data requests.
SecRule FILES_COMBINED_SIZE \u0026quot;@gt 100000\u0026quot; \u0026quot;id:18\u0026quot; FILES_NAMES # Contains a list of form fields that were used for file upload. Available only on inspected multipart/form-data requests.
SecRule FILES_NAMES \u0026quot;^upfile$\u0026quot; \u0026quot;id:19\u0026quot; FULL_REQUEST # Contains the complete request: Request line, Request headers and Request body (if any). The last available only if SecRequestBodyAccess was set to On. Note that all properties of SecRequestBodyAccess will be respected here, such as: SecRequestBodyLimit.
SecRule FULL_REQUEST \u0026quot;User-Agent: Coraza Regression Tests\u0026quot; \u0026quot;id:21\u0026quot; Note : This option is not implemented by default, it must be forced by the server with tx.SetFullRequest()
FULL_REQUEST_LENGTH # Represents the amount of bytes that FULL_REQUEST may use.
SecRule FULL_REQUEST_LENGTH \u0026quot;@eq 205\u0026quot; \u0026quot;id:21\u0026quot; FILES_SIZES # Contains a list of individual file sizes. Useful for implementing a size limitation on individual uploaded files. Available only on inspected multipart/form-data requests.
SecRule FILES_SIZES \u0026quot;@gt 100\u0026quot; \u0026quot;id:20\u0026quot; FILES_TMPNAMES # Contains a list of temporary filesâ€™ names on the disk. Useful when used together with @inspectFile. Available only on inspected multipart/form-data requests.
SecRule FILES_TMPNAMES \u0026quot;@inspectFile /path/to/inspect_script.pl\u0026quot; \u0026quot;id:21\u0026quot; FILES_TMP_CONTENT # Contains a key-value set where value is the content of the file which was uploaded. Useful when used together with @fuzzyHash.
SecRule FILES_TMP_CONTENT \u0026quot;@fuzzyHash $ENV{CONF_DIR}/ssdeep.txt 1\u0026quot; \u0026quot;id:192372,log,deny\u0026quot; Note : SecUploadKeepFiles should be set to \u0026lsquo;On\u0026rsquo; in order to have this collection filled.
GEO # GEO is a collection populated by the results of the last @geoLookup operator. The collection can be used to match geographical fields looked from an IP address or hostname.
Fields:
COUNTRY_CODE: Two character country code. EX: US, CL, GB, etc. COUNTRY_CODE3: Up to three character country code. COUNTRY_NAME: The full country name. COUNTRY_CONTINENT: The two character continent that the country is located. EX: EU REGION: The two character region. For US, this is state. For Chile, region, etc. CITY: The city name if supported by the database. POSTAL_CODE: The postal code if supported by the database. LATITUDE: The latitude if supported by the database. LONGITUDE: The longitude if supported by the database. Example:
SecGeoLookupDb maxminddb file=/usr/local/geo/data/GeoLiteCity.dat ... SecRule REMOTE_ADDR \u0026quot;@geoLookup\u0026quot; \u0026quot;chain,id:22,drop,msg:'Non-GB IP address'\u0026quot; SecRule GEO:COUNTRY_CODE \u0026quot;!@streq GB\u0026quot; HIGHEST_SEVERITY # This variable holds the highest severity of any rules that have matched so far. Severities are numeric values and thus can be used with comparison operators such as @lt, and so on. A value of 255 indicates that no severity has been set.
SecRule HIGHEST_SEVERITY \u0026quot;@le 2\u0026quot; \u0026quot;phase:2,id:23,deny,status:500,msg:'severity %{HIGHEST_SEVERITY}'\u0026quot; Note : Higher severities have a lower numeric value.
INBOUND_DATA_ERROR # This variable will be set to 1 when the request body size is above the setting configured by SecRequestBodyLimit directive. Your policies should always contain a rule to check this variable. Depending on the rate of false positives and your default policy you should decide whether to block or just warn when the rule is triggered.
The best way to use this variable is as in the example below:
SecRule INBOUND_DATA_ERROR \u0026quot;@eq 1\u0026quot; \u0026quot;phase:1,id:24,t:none,log,pass,msg:'Request Body Larger than SecRequestBodyLimit Setting'\u0026quot; MATCHED_VAR # This variable holds the value of the most-recently matched variable. It is similar to the TX:0, but it is automatically supported by all operators and there is no need to specify the capture action.
SecRule ARGS pattern chain,deny,id:25 SecRule MATCHED_VAR \u0026quot;further scrutiny\u0026quot; Note : Be aware that this variable holds data for the last operator match. This means that if there are more than one matches, only the last one will be populated. Use MATCHED_VARS variable if you want all matches.
MATCHED_VARS # Similar to MATCHED_VAR except that it is a collection of all matches for the current operator check.
SecRule ARGS pattern \u0026quot;chain,deny,id:26\u0026quot; SecRule MATCHED_VARS \u0026quot;@eq ARGS:param\u0026quot; MATCHED_VAR_NAME # This variable holds the full name of the variable that was matched against.
SecRule ARGS pattern \u0026quot;chain,deny,id:27\u0026quot; SecRule MATCHED_VAR_NAME \u0026quot;@eq ARGS:param\u0026quot; Note : Be aware that this variable holds data for the last operator match. This means that if there are more than one matches, only the last one will be populated. Use MATCHED_VARS_NAMES variable if you want all matches.
MATCHED_VARS_NAMES # Similar to MATCHED_VAR_NAME except that it is a collection of all matches for the current operator check.
SecRule ARGS pattern \u0026quot;chain,deny,id:28\u0026quot; SecRule MATCHED_VARS_NAMES \u0026quot;@eq ARGS:param\u0026quot; MULTIPART_CRLF_LF_LINES # This flag variable will be set to 1 whenever a multi-part request uses mixed line terminators. The multipart/form-data RFC requires CRLF sequence to be used to terminate lines. Since some client implementations use only LF to terminate lines you might want to allow them to proceed under certain circumstances (if you want to do this you will need to stop using MULTIPART_STRICT_ERROR and check each multi-part flag variable individually, avoiding MULTIPART_LF_LINE). However, mixing CRLF and LF line terminators is dangerous as it can allow for evasion. Therefore, in such cases, you will have to add a check for MULTIPART_CRLF_LF_LINES.
MULTIPART_FILENAME # This variable contains the multipart data from field FILENAME.
MULTIPART_NAME # This variable contains the multipart data from field NAME.
MULTIPART_STRICT_ERROR # MULTIPART_STRICT_ERROR will be set to 1 when any of the following variables is also set to 1: REQBODY_PROCESSOR_ERROR, MULTIPART_BOUNDARY_QUOTED, MULTIPART_BOUNDARY_WHITESPACE, MULTIPART_DATA_BEFORE, MULTIPART_DATA_AFTER, MULTIPART_HEADER_FOLDING, MULTIPART_LF_LINE, MULTIPART_MISSING_SEMICOLON MULTIPART_INVALID_QUOTING MULTIPART_INVALID_HEADER_FOLDING MULTIPART_FILE_LIMIT_EXCEEDED. Each of these variables covers one unusual (although sometimes legal) aspect of the request body in multipart/form-data format. Your policies should always contain a rule to check either this variable (easier) or one or more individual variables (if you know exactly what you want to accomplish). Depending on the rate of false positives and your default policy you should decide whether to block or just warn when the rule is triggered.
The best way to use this variable is as in the example below:
SecRule MULTIPART_STRICT_ERROR \u0026quot;!@eq 0\u0026quot; \\ \u0026quot;phase:2,id:30,t:none,log,deny,msg:'Multipart request body \\ failed strict validation: \\ PE %{REQBODY_PROCESSOR_ERROR}, \\ BQ %{MULTIPART_BOUNDARY_QUOTED}, \\ BW %{MULTIPART_BOUNDARY_WHITESPACE}, \\ DB %{MULTIPART_DATA_BEFORE}, \\ DA %{MULTIPART_DATA_AFTER}, \\ HF %{MULTIPART_HEADER_FOLDING}, \\ LF %{MULTIPART_LF_LINE}, \\ SM %{MULTIPART_MISSING_SEMICOLON}, \\ IQ %{MULTIPART_INVALID_QUOTING}, \\ IQ %{MULTIPART_INVALID_HEADER_FOLDING}, \\ FE %{MULTIPART_FILE_LIMIT_EXCEEDED}'\u0026quot; Coraza uses the golang multipart parser, which fails for most evasion attempts and generates an exception.
MULTIPART_UNMATCHED_BOUNDARY # Set to 1 when, during the parsing phase of a multipart/request-body, Coraza encounters what feels like a boundary but it is not. Such an event may occur when evasion of Coraza is attempted.
Supported: TBI
The best way to use this variable is as in the example below:
SecRule MULTIPART_UNMATCHED_BOUNDARY \u0026quot;!@eq 0\u0026quot; \\ \u0026quot;phase:2,id:31,t:none,log,deny,msg:'Multipart parser detected a possible unmatched boundary.'\u0026quot; Change the rule from blocking to logging-only if many false positives are encountered.
OUTBOUND_DATA_ERROR # This variable will be set to 1 when the response body size is above the setting configured by SecResponseBodyLimit directive. Your policies should always contain a rule to check this variable. Depending on the rate of false positives and your default policy you should decide whether to block or just warn when the rule is triggered.
The best way to use this variable is as in the example below:
SecRule OUTBOUND_DATA_ERROR \u0026quot;@eq 1\u0026quot; \u0026quot;phase:1,id:32,t:none,log,pass,msg:'Response Body Larger than SecResponseBodyLimit Setting'\u0026quot; PATH_INFO # Contains the extra request URI information, also known as path info. (For example, in the URI /index.php/123, /123 is the path info.) Available only in embedded deployments.
SecRule PATH_INFO \u0026quot;^/(bin|etc|sbin|opt|usr)\u0026quot; \u0026quot;id:33\u0026quot; PERF_ALL # This special variable contains a string thatâ€™s a combination of all other performance variables, arranged in the same order in which they appear in the Stopwatch2 audit log header. Itâ€™s intended for use in custom Apache logs
Supported on Coraza: TBI
PERF_COMBINED # Contains the time, in microseconds, spent in Coraza during the current transaction. The value in this variable is arrived to by adding all the performance variables except PERF_SREAD (the time spent reading from persistent storage is already included in the phase measurements).
Supported on Coraza: TBI
PERF_GC Contains the time, in microseconds, spent performing garbage collection.
Supported on Coraza: TBI
PERF_LOGGING # Contains the time, in microseconds, spent in audit logging. This value is known only after the handling of a transaction is finalized, which means that it can only be logged using mod_log_config and the %{VARNAME}M syntax.
Supported on Coraza: TBI
PERF_PHASE1 # Contains the time, in microseconds, spent processing phase 1.
Supported on Coraza: TBI
PERF_PHASE2 # Contains the time, in microseconds, spent processing phase 2.
Supported on Coraza: TBI
PERF_PHASE3 # Contains the time, in microseconds, spent processing phase 3.
Supported on Coraza: TBI
PERF_PHASE4 # Contains the time, in microseconds, spent processing phase 4.
Supported on Coraza: TBI
PERF_PHASE5 # Contains the time, in microseconds, spent processing phase 5.
Supported on Coraza: TBI
PERF_RULES # PERF_RULES is a collection, that is populated with the rules hitting the performance threshold defined with SecRulePerfTime. The collection contains the time, in microseconds, spent processing the individual rule. The various items in the collection can be accessed via the rule id.
Supported on Coraza: TBI
SecRulePerfTime 100 SecRule FILES_TMPNAMES \u0026quot;@inspectFile /path/to/util/runav.pl\u0026quot; \\ \u0026quot;phase:2,id:10001,deny,log,msg:'Virus scan detected an error.'\u0026quot; SecRule \u0026amp;PERF_RULES \u0026quot;@eq 0\u0026quot; \u0026quot;phase:5,id:95000,\\ pass,log,msg:'All rules performed below processing time limit.'\u0026quot; SecRule PERF_RULES \u0026quot;@ge 1000\u0026quot; \u0026quot;phase:5,id:95001,pass,log,\\ msg:'Rule %{MATCHED_VAR_NAME} spent at least 1000 usec.'\u0026quot; SecAction \u0026quot;phase:5,id:95002,pass,log, msg:'File inspection took %{PERF_RULES.10001} usec.'\u0026quot; The rule with id 10001 defines an external file inspection rule. The rule with id 95000 checks the size of the PERF_RULES collection. If the collection is empty, it writes a note in the logfile. Rule 95001 is executed for every item in the PERF_RULES collection. Every item is thus being checked against the limit of 1000 microseconds. If the rule spent at least that amount of time, then a note containing the rule id is being written to the logfile. The final rule 95002 notes the time spent in rule 10001 (the virus inspection).
PERF_SREAD # Contains the time, in microseconds, spent reading from persistent storage.
Supported on Coraza: TBI
PERF_SWRITE # Contains the time, in microseconds, spent writing to persistent storage.
Supported on Coraza: TBI
QUERY_STRING # Contains the query string part of a request URI. The value in QUERY_STRING is always provided raw, without URL decoding taking place.
SecRule QUERY_STRING \u0026quot;attack\u0026quot; \u0026quot;id:34\u0026quot; REMOTE_ADDR # This variable holds the IP address of the remote client.
SecRule REMOTE_ADDR \u0026quot;@ipMatch 192.168.1.101\u0026quot; \u0026quot;id:35\u0026quot; REMOTE_HOST # If the Apache directive HostnameLookups is set to On, then this variable will hold the remote hostname resolved through DNS. If the directive is set to Off, this variable it will hold the remote IP address (same as REMOTE_ADDR). Possible uses for this variable would be to deny known bad client hosts or network blocks, or conversely, to allow in authorized hosts.
SecRule REMOTE_HOST \u0026quot;\\.evil\\.network\\org$\u0026quot; \u0026quot;id:36\u0026quot; REMOTE_PORT # This variable holds information on the source port that the client used when initiating the connection to our web server.
In the following example, we are evaluating to see whether the REMOTE_PORT is less than 1024, which would indicate that the user is a privileged user:
SecRule REMOTE_PORT \u0026quot;@lt 1024\u0026quot; \u0026quot;id:37\u0026quot; REMOTE_USER # This variable holds the username of the authenticated user. If there are no password access controls in place (Basic or Digest authentication), then this variable will be empty.
SecRule REMOTE_USER \u0026quot;@streq admin\u0026quot; \u0026quot;id:38\u0026quot; Note : In a reverse-proxy deployment, this information will not be available if the authentication is handled in the backend web server.
REQBODY_ERROR # Contains the status of the request body processor used for request body parsing. The values can be 0 (no error) or 1 (error). This variable will be set by request body processors (typically the multipart/request-data parser, JSON or the XML parser) when they fail to do their work.
SecRule REQBODY_ERROR \u0026quot;@eq 1\u0026quot; deny,phase:2,id:39 Note : Your policies must have a rule to check for request body processor errors at the very beginning of phase 2. Failure to do so will leave the door open for impedance mismatch attacks. It is possible, for example, that a payload that cannot be parsed by Coraza can be successfully parsed by more tolerant parser operating in the application. If your policy dictates blocking, then you should reject the request if error is detected. When operating in detection-only mode, your rule should alert with high severity when request body processing fails.
REQBODY_ERROR_MSG # If thereâ€™s been an error during request body parsing, the variable will contain the following error message:
SecRule REQBODY_ERROR_MSG \u0026quot;failed to parse\u0026quot; \u0026quot;id:40\u0026quot; REQBODY_PROCESSOR # Contains the name of the currently used request body processor. The possible values are URLENCODED, JSON, MULTIPART, and XML.
SecRule REQBODY_PROCESSOR \u0026quot;^XML$ chain,id:41 SecRule XML://* \u0026quot;something\u0026quot; \u0026quot;id:123\u0026quot; REQUEST_BASENAME # This variable holds just the filename part of REQUEST_FILENAME (e.g., index.php).
SecRule REQUEST_BASENAME \u0026quot;^login\\.php$\u0026quot; phase:2,id:42,t:none,t:lowercase Note : Please note that anti-evasion transformations are not applied to this variable by default. REQUEST_BASENAME will recognize both / and \\ as path separators. You should understand that the value of this variable depends on what was provided in request, and that it does not have to correspond to the resource (on disk) that will be used by the web server.
REQUEST_BODY # Holds the raw request body. This variable is available only if the URLENCODED request body processor was used, which will occur by default when the application/x-www-form-urlencoded content type is detected, or if the use of the URLENCODED request body parser was forced.
SecRule REQUEST_BODY \u0026quot;^username=\\w{25,}\\\u0026amp;password=\\w{25,}\\\u0026amp;Submit\\=login$\u0026quot; \u0026quot;id:43\u0026quot; It is possible to force the presence of the REQUEST_BODY variable, but only when there is no request body processor defined using the ctl:forceRequestBodyVariable option in the REQUEST_HEADERS phase.
REQUEST_BODY_LENGTH # Contains the number of bytes read from a request body.
REQUEST_COOKIES # This variable is a collection of all of request cookies (values only). Example: the following example is using the Ampersand special operator to count how many variables are in the collection. In this rule, it would trigger if the request does not include any Cookie headers.
SecRule \u0026amp;REQUEST_COOKIES \u0026quot;@eq 0\u0026quot; \u0026quot;id:44\u0026quot; REQUEST_COOKIES_NAMES # This variable is a collection of the names of all request cookies. For example, the following rule will trigger if the JSESSIONID cookie is not present:
SecRule \u0026amp;REQUEST_COOKIES_NAMES:JSESSIONID \u0026quot;@eq 0\u0026quot; \u0026quot;id:45\u0026quot; REQUEST_FILENAME # This variable holds the relative request URL without the query string part (e.g., /index.php).
SecRule REQUEST_FILENAME \u0026quot;^/cgi-bin/login\\.php$\u0026quot; phase:2,id:46,t:none,t:normalizePath Note : Please note that anti-evasion transformations are not used on REQUEST_FILENAME, which means that you will have to specify them in the rules that use this variable.
REQUEST_HEADERS # This variable can be used as either a collection of all of the request headers or can be used to inspect selected headers (by using the REQUEST_HEADERS:Header-Name syntax).
SecRule REQUEST_HEADERS:Host \u0026quot;^[\\d\\.]+$\u0026quot; \u0026quot;deny,id:47,log,status:400,msg:'Host header is a numeric IP address'\u0026quot; Note: Coraza will treat multiple headers that have identical names as a \u0026ldquo;list\u0026rdquo;, processing each single value.
REQUEST_HEADERS_NAMES # This variable is a collection of the names of all of the request headers.
SecRule REQUEST_HEADERS_NAMES \u0026quot;^x-forwarded-for\u0026quot; \u0026quot;log,deny,id:48,status:403,t:lowercase,msg:'Proxy Server Used'\u0026quot; REQUEST_LINE # This variable holds the complete request line sent to the server (including the request method and HTTP version information).
# Allow only POST, GET and HEAD request methods, as well as only # the valid protocol versions SecRule REQUEST_LINE \u0026quot;!(^((?:(?:POS|GE)T|HEAD))|HTTP/(0\\.9|1\\.0|1\\.1)$)\u0026quot; \u0026quot;phase:1,id:49,log,block,t:none\u0026quot; REQUEST_METHOD # This variable holds the request method used in the transaction.
SecRule REQUEST_METHOD \u0026quot;^(?:CONNECT|TRACE)$\u0026quot; \u0026quot;id:50,t:none\u0026quot; REQUEST_PROTOCOL # This variable holds the request protocol version information.
SecRule REQUEST_PROTOCOL \u0026quot;!^HTTP/(0\\.9|1\\.0|1\\.1)$\u0026quot; \u0026quot;id:51\u0026quot; ##Â REQUEST_URI
This variable holds the full request URL including the query string data (e.g., /index.php? p=X). However, it will never contain a domain name, even if it was provided on the request line.
SecRule REQUEST_URI \u0026quot;attack\u0026quot; \u0026quot;phase:1,id:52,t:none,t:urlDecode,t:lowercase,t:normalizePath\u0026quot; Note : Please note that anti-evasion transformations are not used on REQUEST_URI, which means that you will have to specify them in the rules that use this variable.
REQUEST_URI_RAW # Same as REQUEST_URI but will contain the domain name if it was provided on the request line (e.g., http://www.example.com/index.php?p=X).
SecRule REQUEST_URI_RAW \u0026quot;http:/\u0026quot; \u0026quot;phase:1,id:53,t:none,t:urlDecode,t:lowercase,t:normalizePath\u0026quot; Note : Please note that anti-evasion transformations are not used on REQUEST_URI_RAW, which means that you will have to specify them in the rules that use this variable.
RESPONSE_BODY # This variable holds the data for the response body, but only when response body buffering is enabled.
SecRule RESPONSE_BODY \u0026quot;ODBC Error Code\u0026quot; \u0026quot;phase:4,id:54,t:none\u0026quot; RESPONSE_CONTENT_LENGTH # Response body length in bytes. Can be available starting with phase 3, but it does not have to be (as the length of response body is not always known in advance). If the size is not known, this variable will contain a zero. If RESPONSE_CONTENT_LENGTH contains a zero in phase 5 that means the actual size of the response body was 0. The value of this variable can change between phases if the body is modified. For example, in embedded mode, mod_deflate can compress the response body between phases 4 and 5.
RESPONSE_CONTENT_TYPE # Response content type. Available only starting with phase 3. The value available in this variable is taken directly from the internal structures of Apache, which means that it may contain the information that is not yet available in response headers. In embedded deployments, you should always refer to this variable, rather than to RESPONSE_HEADERS:Content-Type.
RESPONSE_HEADERS # This variable refers to response headers, in the same way as REQUEST_HEADERS does to request headers.
SecRule RESPONSE_HEADERS:X-Cache \u0026quot;MISS\u0026quot; \u0026quot;id:55\u0026quot; This variable may not have access to some headers when running in embedded mode. Headers such as Server, Date, Connection, and Content-Type could be added just prior to sending the data to the client. This data should be available in phase 5 or when deployed in proxy mode.
RESPONSE_HEADERS_NAMES # This variable is a collection of the response header names.
SecRule RESPONSE_HEADERS_NAMES \u0026quot;Set-Cookie\u0026quot; \u0026quot;phase:3,id:56,t:none\u0026quot; The same limitations apply as the ones discussed in RESPONSE_HEADERS.
RESPONSE_PROTOCOL # This variable holds the HTTP response protocol information.
SecRule RESPONSE_PROTOCOL \u0026quot;^HTTP\\/0\\.9\u0026quot; \u0026quot;phase:3,id:57,t:none\u0026quot; RESPONSE_STATUS # This variable holds the HTTP response status code:
SecRule RESPONSE_STATUS \u0026quot;^[45]\u0026quot; \u0026quot;phase:3,id:58,t:none\u0026quot; This variable may not work as expected, as some implementations might change the status before releasing the output buffers.
RULE # This is a special collection that provides access to the id, rev, severity, logdata, and msg fields of the rule that triggered the action. It can be used to refer to only the same rule in which it resides.
SecRule \u0026amp;REQUEST_HEADERS:Host \u0026quot;@eq 0\u0026quot; \u0026quot;log,deny,id:59,setvar:tx.varname=%{RULE.id}\u0026quot; SERVER_ADDR # This variable contains the IP address of the server.
SecRule SERVER_ADDR \u0026quot;@ipMatch 192.168.1.100\u0026quot; \u0026quot;id:67\u0026quot; SERVER_NAME # This variable contains the transactionâ€™s hostname or IP address, taken from the request itself (which means that, in principle, it should not be trusted).
SecRule SERVER_NAME \u0026quot;hostname\\.com$\u0026quot; \u0026quot;id:68\u0026quot; SERVER_PORT # This variable contains the local port that the web server (or reverse proxy) is listening on.
SecRule SERVER_PORT \u0026quot;^80$\u0026quot; \u0026quot;id:69\u0026quot; SESSION # This variable is a collection that contains session information. It becomes available only after setsid is executed.
The following example shows how to initialize SESSION using setsid, how to use setvar to increase the SESSION.score values, how to set the SESSION.blocked variable, and finally, how to deny the connection based on the SESSION:blocked value:
# Initialize session storage SecRule REQUEST_COOKIES:PHPSESSID !^$ \u0026quot;phase:2,id:70,nolog,pass,setsid:%{REQUEST_COOKIES.PHPSESSID}\u0026quot; # Increment session score on attack SecRule REQUEST_URI \u0026quot;^/cgi-bin/finger$\u0026quot; \u0026quot;phase:2,id:71,t:none,t:lowercase,t:normalizePath,pass,setvar:SESSION.score=+10\u0026quot; # Detect too many attacks in a session SecRule SESSION:score \u0026quot;@gt 50\u0026quot; \u0026quot;phase:2,id:72,pass,setvar:SESSION.blocked=1\u0026quot; # Enforce session block SecRule SESSION:blocked \u0026quot;@eq 1\u0026quot; \u0026quot;phase:2,id:73,deny,status:403\u0026quot; SESSIONID # This variable contains the value set with setsid. See SESSION (above) for a complete example.
STATUS_LINE # This variable holds the full status line sent by the server (including the request method and HTTP version information).
# Generate an alert when the application generates 500 errors. SecRule STATUS_LINE \u0026quot;@contains 500\u0026quot; \u0026quot;phase:3,id:49,log,pass,logdata:'Application error detected!,t:none\u0026quot; Version: 2.x Supported on Coraza: TBI
TIME # This variable holds a formatted string representing the time (hour:minute:second).
SecRule TIME \u0026quot;^(([1](8|9))|([2](0|1|2|3))):\\d{2}:\\d{2}$\u0026quot; \u0026quot;id:74\u0026quot; TIME_DAY # This variable holds the current date (1â€“31). The following rule triggers on a transaction thatâ€™s happening anytime between the 10th and 20th in a month:
SecRule TIME_DAY \u0026quot;^(([1](0|1|2|3|4|5|6|7|8|9))|20)$\u0026quot; \u0026quot;id:75\u0026quot; TIME_EPOCH # This variable holds the time in seconds since 1970.
TIME_HOUR # This variable holds the current hour value (0â€“23). The following rule triggers when a request is made â€œoff hoursâ€:
SecRule TIME_HOUR \u0026quot;^(0|1|2|3|4|5|6|[1](8|9)|[2](0|1|2|3))$\u0026quot; \u0026quot;id:76\u0026quot; TIME_MIN # This variable holds the current minute value (0â€“59). The following rule triggers during the last half hour of every hour:
SecRule TIME_MIN \u0026quot;^(3|4|5)\u0026quot; \u0026quot;id:77\u0026quot; TIME_MON # This variable holds the current month value (0â€“11). The following rule matches if the month is either November (value 10) or December (value 11):
SecRule TIME_MON \u0026quot;^1\u0026quot; \u0026quot;id:78\u0026quot; TIME_SEC # This variable holds the current second value (0â€“59).
Supported: TBI
SecRule TIME_SEC \u0026quot;@gt 30\u0026quot; \u0026quot;id:79\u0026quot; TIME_WDAY # This variable holds the current weekday value (0â€“6). The following rule triggers only on Satur- day and Sunday:
Supported: TBI
SecRule TIME_WDAY \u0026quot;^(0|6)$\u0026quot; \u0026quot;id:80\u0026quot; TIME_YEAR # This variable holds the current four-digit year value.
Supported: TBI
SecRule TIME_YEAR \u0026quot;^2006$\u0026quot; \u0026quot;id:81\u0026quot; TX # This is the transient transaction collection, which is used to store pieces of data, create a transaction anomaly score, and so on. The variables placed into this collection are available only until the transaction is complete.
# Increment transaction attack score on attack SecRule ARGS attack \u0026quot;phase:2,id:82,nolog,pass,setvar:TX.score=+5\u0026quot; # Block the transactions whose scores are too high SecRule TX:SCORE \u0026quot;@gt 20\u0026quot; \u0026quot;phase:2,id:83,log,deny\u0026quot; Some variable names in the TX collection are reserved and cannot be used:
TX:0: the matching value when using the @rx or @pm operator with the capture action TX:1-TX:9: the captured subexpression value when using the @rx operator with capturing parens and the capture action UNIQUE_ID # This variable holds the unique id for the transaction.
URLENCODED_ERROR # This variable is created when an invalid URL encoding is encountered during the parsing of a query string (on every request) or during the parsing of an application/x-www-form-urlencoded request body (only on the requests that use the URLENCODED request body processor).
USERID # This variable contains the value set with setuid.
Supported: TBI
# Initialize user tracking SecAction \u0026quot;nolog,id:84,pass,setuid:%{REMOTE_USER}\u0026quot; # Is the current user the administrator? SecRule USERID \u0026quot;admin\u0026quot; \u0026quot;id:85\u0026quot; WEBAPPID # This variable contains the current application name, which is set in configuration using SecWebAppId.
Supported: TBI
XML # Special collection used to interact with the XML parser. It must contain a valid XPath expression, which will then be evaluated against a previously parsed XML DOM tree.
SecDefaultAction log,deny,status:403,phase:2,id:90 SecRule REQUEST_HEADERS:Content-Type ^text/xml$ \u0026quot;phase:1,id:87,t:lowercase,nolog,pass,ctl:requestBodyProcessor=XML\u0026quot; SecRule REQBODY_PROCESSOR \u0026quot;!^XML$\u0026quot; skipAfter:12345,id:88 It would match against payload such as this one:
\u0026lt;employees\u0026gt; \u0026lt;employee\u0026gt; \u0026lt;name\u0026gt;Fred Jones\u0026lt;/name\u0026gt; \u0026lt;address location=\u0026quot;home\u0026quot;\u0026gt; \u0026lt;street\u0026gt;900 Aurora Ave.\u0026lt;/street\u0026gt; \u0026lt;city\u0026gt;Seattle\u0026lt;/city\u0026gt; \u0026lt;state\u0026gt;WA\u0026lt;/state\u0026gt; \u0026lt;zip\u0026gt;98115\u0026lt;/zip\u0026gt; \u0026lt;/address\u0026gt; \u0026lt;address location=\u0026quot;work\u0026quot;\u0026gt; \u0026lt;street\u0026gt;2011 152nd Avenue NE\u0026lt;/street\u0026gt; \u0026lt;city\u0026gt;Redmond\u0026lt;/city\u0026gt; \u0026lt;state\u0026gt;WA\u0026lt;/state\u0026gt; \u0026lt;zip\u0026gt;98052\u0026lt;/zip\u0026gt; \u0026lt;/address\u0026gt; \u0026lt;phone location=\u0026quot;work\u0026quot;\u0026gt;(425)555-5665\u0026lt;/phone\u0026gt; \u0026lt;phone location=\u0026quot;home\u0026quot;\u0026gt;(206)555-5555\u0026lt;/phone\u0026gt; \u0026lt;phone location=\u0026quot;mobile\u0026quot;\u0026gt;(206)555-4321\u0026lt;/phone\u0026gt; \u0026lt;/employee\u0026gt; \u0026lt;/employees\u0026gt; `}),e.add({id:23,href:"/docs/tutorials/quick-start/",title:"Quick Start",description:"One page summary of how to start a new Coraza WAF project.",content:`If you are not looking to use Coraza WAF as a library and you want a working WAF implementation or integration, check the integrations page.
Requirements # Golang 1.17+ Add Coraza to your go project # go get github.com/coraza-waf/coraza/v3@latest Create a WAF instance # WAF instances are the main container for settings and rules which are inherited by transactions that will process requests, responses and logging. A WAF instance can be created like this:
package main import ( \u0026quot;github.com/coraza-waf/coraza/v3\u0026quot; ) func initCoraza(){ coraza.NewWaf() } Adding rules to a Waf Instance # Seclang rules syntax is used to create Coraza Rules which will be evaluated by transactions and apply disruptive actions like deny(403) or just log the event. See the Seclang references.
Rules are unmarshaled using the seclang package which provides functionalities to compile rules from files or strings.
package main import ( \u0026quot;github.com/coraza-waf/coraza/v3\u0026quot; \u0026quot;github.com/coraza-waf/coraza/v3/seclang\u0026quot; ) func parseRules(waf *coraza.Waf){ parser := seclang.NewParser(waf) if err := parser.FromString(\`SecAction \u0026quot;id:1,phase:1,deny:403,log\u0026quot;\`); err != nil { panic(err) } } Creating a transaction # Transactions are created for each http request, they are concurrent-safe and they handle Phases to evaluate rules and generate audit and interruptions. A transaction can be created using waf.NewTransaction().
Handling an interruption # Interruptions are created by Transactions to tell the web server or application what action is required, based on the rules actions. Interruptions can be retrieved using tx.Interruption, a nil Interruption means there is no action needed (pass) and a non-nil interruption means the web server must do something like denying the request. For example:
//... tx := waf.NewTransaction() // Add some variables and process some phases if it := tx.Interruption;it != nil { switch it.Action { case \u0026quot;deny\u0026quot;: rw.WriteStatus(it.Status) rw.Write([]byte(\u0026quot;Some error message\u0026quot;)) return } } Handling a request # There are two ways to handle a Request, you can manually process each phase for the request or you can send a http.Request to Coraza.
To process an http.Request struct you must use the tx.ProcessRequest(req) helper. ProcessRequest will evaluate phases 1 and 2, and will stop the execution flow if the transaction was disrupted. Important: req.Body will be read replaced with a new pointer, pointing to a buffer or file created by Coraza.
To manually process a request we must run 5 functions in the following order:
ProcessConnection: Creates variables with connection information like IP addresses and ports. ProcessUri: Creates variables from strings extracted from the Request Line, these are method, url and protocol. AddRequestHeader: Must be run for each HTTP header, it will create headers variables and cookies. ProcessRequestHeaders: Evaluates phase 1 rules with all the variables felt before. This functions is disruptive. RequestBodyBuffer.Write: Writes to the request body buffer, you can just io.Copy(tx.RequestBodyBuffer, someReader) ProcessRequestBody: Evaluates phase 2 rules with the REQUEST_BODY and POST variables. There are other cases like MULTIPART, JSON and XML tx := waf.NewTransaction() // 127.0.0.1:55555 -\u0026gt; 127.0.0.1:80 tx.ProcessConnection(\u0026quot;127.0.0.1\u0026quot;, 55555, \u0026quot;127.0.0.1\u0026quot;, 80) // Request URI was /some-url?with=args tx.ProcessURI(\u0026quot;/some-url?with=args\u0026quot;) // We add some headers tx.AddRequestHeader(\u0026quot;Host\u0026quot;, \u0026quot;somehost.com\u0026quot;) tx.AddRequestHeader(\u0026quot;Cookie\u0026quot;, \u0026quot;some-cookie=with-value\u0026quot;) // Content-Type is important to tell coraza which BodyProcessor must be used tx.AddRequestHeader(\u0026quot;Content-Type\u0026quot;, \u0026quot;application/x-www-form-urlencoded\u0026quot;) // We process phase 1 (Request) if it := tx.ProcessRequestHeaders();it != nil { return processInterruption(it) } // We add urlencoded POST data tx.RequestBodyBuffer.Write([]byte(\u0026quot;somepost=data\u0026amp;with=paramenters\u0026quot;)) // We process phase 2 (Request Body) if it := tx.ProcessRequestBody();it != nil { return processInterruption(it) } Handling a response # Responses are harder to handler, that\u0026rsquo;s why there is no helper to do that. Many integrations requires you to create \u0026ldquo;body interceptors\u0026rdquo; or other kind of functions.
There is a special helper, IsProcessableResponseBody that returns true if the request can be intercepted by Coraza In the magical case that you are handling an http.Response or a bytes buffer, you can use:
tx := waf.NewTransaction() //parse request... tx.AddResponseHeader(\u0026quot;some\u0026quot;, \u0026quot;header\u0026quot;) if it := tx.ProcessResponseHeaders(200); it != nil { return processInterruption(it) } if !tx.IsProcessableResponseBody() { // We stream the response to the client sw.WriteStatus(200) sw.Write(res.Body) sw.Close() return } //Add response data from a string or bytes: tx.ResponseBodyBuffer.Write([]byte(\u0026quot;some response data\u0026quot;)) //Or dump a Response.Body buffer into Coraza io.Copy(tx.ResponseBodyBuffer, res.Body) sw.WriteStatus(200) sw.Write(tx.ResponseBodyBuffer.Reader()) sw.Close() Handling logging # Logging is a mandatory phase that has to be processed even if the transaction was disrupted. The best way to force calling ProcessLogging() is to use defer, for example:
//... tx := waf.NewTransaction() defer tx.ProcessLogging() //Process phases `}),e.add({id:24,href:"/docs/tutorials/coreruleset/",title:"OWASP Core Ruleset",description:"OWASP Core Ruleset is the most robust open source WAF rule set available in the internet, compatible with Coraza",content:`Important: OWASP Core Ruleset requires coraza-libinjection and coraza-pcre plugins to work. There is an upcoming fork that removes the need for the plugins by removing a few features and rewriting some @rx operators to RE2 instead of PCRE.
Installation # Core Ruleset can be normally installed by importing each required file in the following order:
wget https://raw.githubusercontent.com/jptosso/coraza-waf/v2/master/coraza.conf-recommended -O coraza.conf git clone https://github.com/coreruleset/coreruleset coraza.conf coreruleset/crs-setup.conf.example coreruleset/rules/*.conf For example:
func initCoraza(){ waf := coraza.NewWaf() parser, _ := seclang.NewParser(waf) files := []string{ \u0026quot;coraza.conf\u0026quot;, \u0026quot;coreruleset/crs-setup.conf.example\u0026quot;, \u0026quot;coreruleset/rules/*.conf\u0026quot;, } for _, f := range files { if err := parser.FromFile(f); err != nil { panic(err) } } } Configuration # Please check https://coreruleset.org/installation/ for configuration examples.
`}),e.add({id:25,href:"/docs/reference/internals/",title:"Internals",description:`WAF Engine # Waf is the main interface used to store settings, rules and create transactions, most directives will set variables for Waf instances. A coraza implementation might have unlimited Waf instances and each Waf might process unlimited transactions.
Transactions # Transactions are an instance of an url call for a Waf instance, transactions are created with wafinstance.NewTransaction(). Transactions holds collections and configurations that may be updated using rules.
Macro Expansion # Macro expansions are a function available for transactions, a macro expansion will compile a string and provide variables data to the current context.`,content:`WAF Engine # Waf is the main interface used to store settings, rules and create transactions, most directives will set variables for Waf instances. A coraza implementation might have unlimited Waf instances and each Waf might process unlimited transactions.
Transactions # Transactions are an instance of an url call for a Waf instance, transactions are created with wafinstance.NewTransaction(). Transactions holds collections and configurations that may be updated using rules.
Macro Expansion # Macro expansions are a function available for transactions, a macro expansion will compile a string and provide variables data to the current context. Macro expansion is performed by running a regular expresion that will find %{request_headers.test} and replace it with it\u0026rsquo;s value using:
v1 := tx.GetCollection(variables.RequestHeaders).GetFirstString(\u0026quot;test\u0026quot;) v2 := tx.MacroExpansion(\u0026quot;%{request_headers.test}\u0026quot;) v1 == v2 // true Rules # Rules are triggered by RuleGroup.Evaluate(phase) based on the phase number, rules with phase 0 or rule.AlwaysMatch will always run. Rules that always run are SecMarkers or SecActions which means rules without operators.
Rules marked with a SecMarker will be used to control execution flow and tell the transaction to stop skipping rules from skipAfter.
Different from ModSecurity, each rule is a unique struct in Coraza and is shared between each transaction of the same Waf instance, which means a transaction should never update any field from a Rule and all variable fields must be stored within the transaction instead.
Once a rule is triggered, it will follow the following flow:
Skip if this rule is removed for the current transaction Fill the RULE variable data which contain fields from the current rule Apply removed targets for this transaction Compile each variable, normal, counters, negations and \u0026ldquo;always match\u0026rdquo; Apply transformations for each variable, match or multimatch Execute the current operator for each variable Continue if there was any match Evaluate all non-disruptive actions Evaluate chains recursively Log data if requested Evaluate disruptive and flow rules The return of this function contains each MatchData, which will tell the transaction where exactly the data was matched, Variable, Key and Value. Maybe we should add if it was negation in the future, SecActions and SecMarkers will return a placeholder.
Important: Rules may update a Transaction behaviour but not a Waf instance.
Operators # Operators are stored in github.com/coraza-waf/coraza/v2/operators and contains an initializer and an evaluation function. Initializers are used to apply arguments during compilation, for example, \u0026quot;@rx /\\d+/\u0026quot; will run op.Init(\u0026quot;/\\\\d+\u0026quot;). op.Evaluate(tx, \u0026quot;args\u0026quot;) is applied for each compiled variable and will return if the condition matches. Operators uses Transaction to create logs, capture fields and access additional variables from the transaction.
Note: Operators must be concurrent-friendly
Actions # Actions are stored in github.com/coraza-waf/coraza/v2/actions and contains an initializer and an evaluation function, the initializers are evaluated during compilation, for example, id:4 will run act.Init(\u0026quot;4\u0026quot;). Depending on the Type() of each action, it will run on different phases.
Non-Disruptive: Do something, but that something does not and cannot affect the rule processing flow. Setting a variable, or changing its value is an example of a non-disruptive action. Non-disruptive action can appear in any rule, including each rule belonging to a chain. Non-disruptive rules are evaluated after the rule matches some data. Flow actions: These actions affect the rule flow (for example skip or skipAfter). Flow actions are evaluated after the rule successfully matched and will only run for the parent rule of a chain. Meta-data actions: Meta-data actions are used to provide more information about rules. Examples include id, rev, severity and msg. Meta-data rules are only initialized, they won\u0026rsquo;t be evaluated, act.Evaluate(...) will never be called. Transformations # Transformations are simple functions to transform some string into another string. There is a special struct called transactions.Tools, that contains useful \u0026ldquo;tools\u0026rdquo; required for some transformations, which are UnicodeMapping for utf8ToUnicode and waf.Logger to debug transformations. More fields may be added in the future.
Note: Transformations are evaluated thousands of times per transaction and they must be SUPER FAST.
Rule Groups # Rule Groups are like Modsecurity Rules, it\u0026rsquo;s just a container for rules that will return the list of rules concurrent-safe and will evaluate rules based on the requested phase.
Collections # Collections are used by Coraza to store Variables, all Variables are treated as the same type, even if they map values, they are single values or arrays.
Collections are stored as a slice []*Collection, each index is assigned based on it\u0026rsquo;s constant name provided by variables.go. For example, if you want to get a collection you might use tx.GetCollection(variables.Files). If you want to transform a named variable to it\u0026rsquo;s constant you may use:
b, _ := variables.ParseVariable(\u0026quot;FILES\u0026quot;) tx.GetCollection(b) In the following example we are showing the output for tx.GetCollection(variables.RequestHeaders).Data().
{ \u0026quot;user-agent\u0026quot;: [ \u0026quot;some user agent string\u0026quot; ] } Some helpers may be used for this cases, like tx.GetCollection(variables.RequestHeaders).GetFirstString(\u0026quot;\u0026quot;).
Variables are compiled in runtime in order to support Regex(precompiled) and XML, the function tx.GetField(variable). Using RuleVariable.Exceptions and []exceptions might seem redundant but both are different, the list of exception is complemented from the rule. In case of Regex, GetField will use RuleVariable.Regex to match data instead of RuleVariable.Key.
Note: Collections are not concurrent-safe, don\u0026rsquo;t share transactions between routines.
Phases # Phases are used by RuleGroup to filter between execution phases on HTTP/1.1 and HTTP/1.0.
Phase 1: Request Headers
This phase process theorically consists in three phases:
Connection (tx.ProcessConnection()): Request address and port Request line (tx.ProcessURI()): Request URL, does not include GET arguments Request headers (tx.ProcessRequestHeaders()) Will evaluate phase 1 Phase 2: Request Body
This phase only runs when RequestBodyAcces is On, otherwise we will skip to phase 3. This phase will do one of the following:
Reject transaction if the request body is too long and RequestBodyLimitAction is set to Reject If URLENCODED: set POST arguments and request_Body If MULTIPART: Parse files and set FILES variables If JSON: Not implemented yet If none of the above was met and ForceRequestBodyVariable is set to true, URLENCODED will be forced See Body Handling for more info.
Phase 3: Response Headers
Phase 4: Response Body
Phase 5: Logging
This is a special phase, it will always run but it must be handled by the client. For example, if there is any error reported by Coraza, the client must at least implement a defer tx.ProcessLogging(). This phase will close handlers, save persistent collections and write audit loggers, in order to write the audit loggers the following conditions must be met:
Transaction was marked with auditlog action There must be at least one audit logger (SecAuditLog) AuditEngine must be On or RelevantOnly If AuditEngine was set to RelevantOnly the response status must match AuditLogRelevantStatus Body handling # BodyBuffer is a struct that will manage the request or response buffer and store the data to temprary files if required. BodyBuffer will apply a few rules to decide whether to buffer the data in memory or write a temporary file, it will also return a Reader to the memory buffer or the temporary file created. Temporary files must be deleted by tx.ProccessLoging.
Persistent Collections # Not working yet.
The tx.ProcessRequest(req) helper # `}),e.add({id:26,href:"/docs/tutorials/using-plugins/",title:"Using Plugins",description:"Plugins can extend most Coraza functionalities like, audit logging, geo ip, operators, actions, transformations and body processors.",content:`Plugins must be included in your project\u0026rsquo;s main package, for example:
package main include( \u0026quot;github.com/coraza-waf/coraza/v2\u0026quot; _ \u0026quot;github.com/jptosso/coraza-libinjection\u0026quot; ) The previous code will automatically add the @detectXSS and @detectSQLi operators. (Please note this plugin requires libinjection)
`}),e.add({id:27,href:"/docs/tutorials/upgrade/",title:"Upgrave to v3 ðŸ†•",description:"This tutorial details the steps requiring to upgrade your Coraza v2 application to Coraza v3.",content:`We made a big effort for v3 to keep the API similar to the previous version. But some minor changes are still needed for migrating to the new major release.
This tutorial details the steps requiring to upgrade your Coraza v2 application to Coraza v3.
Seclang parser # NewParser now panics instead of returning an error, and it doesn\u0026rsquo;t need the waf as parameter.
// old code: parser, err := seclang.NewParser(waf) // new code: parser := seclang.NewParser() Directives and rules # No changes required.
Plugins Interfaces # Soon
`}),e.add({id:28,href:"/docs/reference/benchmarks/",title:"Benchmarks",description:"Tests description # Tests are performed using OWASP Core Ruleset v4 and go benchmarks. The benchmark tool supports coraza v2, v3 and modsecurity. Modsecurity is executed using CGO. There are currently 4 test-cases and 7 variations: JSON request: 1kb and 100kb payload URLENCODED request: 1kb and 100kb payload Multipart file upload: 1kb and 100kb payload GET request: no body Results # Machine specs: Apple M1 Pro (10 cores, 16 GB RAM)",content:`Tests description # Tests are performed using OWASP Core Ruleset v4 and go benchmarks. The benchmark tool supports coraza v2, v3 and modsecurity. Modsecurity is executed using CGO. There are currently 4 test-cases and 7 variations: JSON request: 1kb and 100kb payload URLENCODED request: 1kb and 100kb payload Multipart file upload: 1kb and 100kb payload GET request: no body Results # Machine specs: Apple M1 Pro (10 cores, 16 GB RAM)
Values are requests analyzed per second. The higher the value, the better results.
Test Coraza v2 Coraza v3 Modsecurity Simple JSON Request 639 903 1011 Giant JSON Request 603 908 847 Multipart Request 606 817 976 Giant Multipart Request 573 781 958 Simple GET Request 654 955 1135 Simple URLENCODED Request 624 892 842 Giant URLENCODED Request 632 871 840 Test Versions:
Coraza v3: v3.0.0-dev (no tag) Coraza v2: v2.0.1 Modsecurity v3: v3.0.7 Run your own benchmarks # Using golang # # compile modsecurity: https://github.com/SpiderLabs/ModSecurity/wiki/Compilation-recipes-for-v3.x git clone https://github.com/jptosso/coraza-benchmark cd coraza-benchmark go test -bench=. ./... Using Docker # docker run jptosso/coraza-benchmark:latest `}),e.add({id:29,href:"/docs/reference/body-processing/",title:"Body Processing",description:`BodyBuffer # BodyBuffer is used to effectively handle large bodies. Coraza has to buffer the body in order to make reliable blocking possible. Future versions might implement a more efficient solution.
BodyBuffer.Reader is a io.Reader that reads from either a memory buffer or a file. Using files is disabled for tinygo.
Important: Copying a Reader to BodyBuffer will most likely flush the original reader. In most cases you will have to keep two copies of the reader, one for coraza, and one for your application.`,content:`BodyBuffer # BodyBuffer is used to effectively handle large bodies. Coraza has to buffer the body in order to make reliable blocking possible. Future versions might implement a more efficient solution.
BodyBuffer.Reader is a io.Reader that reads from either a memory buffer or a file. Using files is disabled for tinygo.
Important: Copying a Reader to BodyBuffer will most likely flush the original reader. In most cases you will have to keep two copies of the reader, one for coraza, and one for your application. You can simply replace your reader pointer with the BodyBuffer reader pointer.
Body Processors # Body processors are designed to handle requests and responses in the same context. Most processors can handle either a request or a response, but there are cases of body processors like JSON, that can handle request and response in different context. Request-Response correlation is the responsibility of the processor, and the current use-case is GraphQL.
Body Processor Request Response Correlation Tinygo support URLEncoded Yes No No Yes XML (Partial Support) Yes Yes No No Multipart Yes No No Yes JSON Yes Yes No Yes GraphQL TBD TBD Yes TBD `}),e.add({id:30,href:"/docs/reference/extending/",title:"Extending",description:"Easily extend Coraza with your own Operators, Actions, Audit Loggers and Persistence engines.",content:` Rule Operators: Create rule operators like @even to detect even numbers Rule Transformations: Create rule transformations like t:rot13 to encode your values in ROT13 Rule Actions: Create rule actions like challenge to redirect a malicious request to some bot detection system The plugin interface provides three functions to extend rule operators, transformations and actions. Each one of them must match it\u0026rsquo;s proper type or interface and be registered using the plugins package.
Operators: type PluginOperatorWrapper() types.RuleOperator Actions: type PluginOperatorWrapper() types.RuleAction Transformations: type Transformation = func(input string, tools *transformations.Tools) string After defining the plugins, we must register them using the plugins.Register... function inside the init function func init(){}.
Operators: operators.RegisterPlugin(operator PluginOperatorWrapper) Actions: actions.RegisterPlugin(action PluginActionWrapper) Transformations: transformations.RegisterPlugin(transformation transformations.Transformation) Important: Some integrations like Traefik does not support plugins, because we cannot control how the integration is compiled by Pilot.
Installing a plugin # Plugin model is based on Caddy plugins system, they must be compiled within the project just by importing them like this:
import( \u0026quot;github.com/coraza-waf/coraza/v2\u0026quot; _ \u0026quot;github.com/someone/somecorazaplugin\u0026quot; ) Creating Rule Actions # Rule Action interface # type RuleAction interface { // Initializes an action, will be done during compilation Init(*Rule, string) error // Evaluate will be done during rule evaluation Evaluate(*Rule, *Transaction) // Type will return the rule type, it's used by Evaluate // to choose when to evaluate each action Type() types.RuleActionType } Action types # Each action can have one type that defines in which part of the rule lifetime it will be evaluated.
ACTION_TYPE_DISRUPTIVE: Cause Coraza to do something. In many cases something means block transaction, but not in all. For example, the allow action is classified as a disruptive action, but it does the opposite of blocking. There can only be one disruptive action per rule (if there are multiple disruptive actions present, or inherited, only the last one will take effect), or rule chain (in a chain, a disruptive action can only appear in the first rule). ACTION_TYPE_NONDISRUPTIVE: Do something, but that something does not and cannot affect the rule processing flow. Setting a variable, or changing its value is an example of a non-disruptive action. Non-disruptive action can appear in any rule, including each rule belonging to a chain. ACTION_TYPE_FLOW: These actions affect the rule flow (for example skip or skipAfter). ACTION_TYPE_METADATA: Meta-data actions are used to provide more information about rules. Examples include id, rev, severity and msg. ACTION_TYPE_DATA: - Not really actions, these are mere containers that hold data used by other actions. For example, the status action holds the status that will be used for blocking (if it takes place). Creating a custom action # type id15 struct{} // Initializes an action, will be done during compilation func (id15) Init(rule *coraza.Rule, _ string) error { rule.Id = 15 return nil } // Evaluate will be done during rule evaluation func (id15) Evaluate(_ *coraza.Rule, _ *coraza.Transaction) {} // ACTION_TYPE_DATA will be only evaluated while compiling the rule, Evaluate won't be called func (id15) Type() int { return coraza.ACTION_TYPE_DATA } // Tripwire to match coraza.RuleAction type var _ coraza.RuleAction = \u0026amp;id15{} Transforming the action to plugin # Once the action is created, it must be wrapper inside a type PluginActionWrapper = func() types.RuleAction in order to be registered.
import( \u0026quot;github.com/coraza-waf/coraza/v2/actions\u0026quot; \u0026quot;github.com/coraza-waf/coraza/v2/types\u0026quot; ) func init() { actions.RegisterPlugin(\u0026quot;id15\u0026quot;, func() types.RuleAction { return \u0026amp;id15{} }) } After properly importing the plugin, you may be able to create rules with id15 action, for example:
SecAction \u0026quot;id15, nolog, pass\u0026quot; Creating Rule Transformations # Transformations are the easiest components to extend, each transformation implements the transformations.Transformation type and can be registered directly using plugins.RegisterPlugin(transformation transformations.Transformation).
The *Tools struct is designed to add additional functionalities like logging and unicode mapping.
Transformation Type # type Transformation = func(input string, tools *Tools) string Example # import ( \u0026quot;github.com/coraza-waf/coraza/v2/transformations\u0026quot; \u0026quot;strings\u0026quot; ) func transformationToLowercase(input string) (string, error) { return strings.ToLower(input) } func init() { transformations.RegisterPlugin(\u0026quot;tolower2\u0026quot;, transformationToLowercase) } Creating Rule Operators # Rule Operator interface # // Operator interface is used to define rule @operators type Operator interface { // Init is used during compilation to setup and cache // the operator Init(string) error // Evaluate is used during the rule evaluation, // it returns true if the operator succeeded against // the input data for the transaction Evaluate(*Transaction, string) bool } Creating a custom operator # type opEven struct{} func (opEven) Init(_ string) error { return nil } func (opEven) Evaluate(_ *coraza.Transaction, input string) bool { i, _ := strconv.Atoi(input) return i%2 == 0 } //Tripwire var _ coraza.Operator = \u0026amp;opEven{} Transforming the operator to plugin # Once the operator is created, it must be wrapper inside a type PluginOperatorWrapper = func() coraza.Operator in order to be registered.
import( \u0026quot;github.com/coraza-waf/coraza/v2/operators\u0026quot; \u0026quot;github.com/coraza-waf/coraza/v2/types\u0026quot; ) func init() { operators.RegisterPlugin(\u0026quot;even\u0026quot;, func() types.Operator { return \u0026amp;opEven{} }) } After properly importing the plugin, you may be able to create rules with even operator, for example:
SecRule ARGS:id \u0026quot;@even\u0026quot; \u0026quot;id:1, nolog, pass\u0026quot; Testing your plugin # There are no special helpers to test plugins but you may use the seclang compiler to achieve this, for example, if we want to test that the tolower2 transformation works we must write the following test:
import( \u0026quot;github.com/jptosso/coraza-waf/v2/seclang\u0026quot; \u0026quot;github.com/jptosso/coraza-waf/v2/types\u0026quot; \u0026quot;github.com/jptosso/coraza-waf/v2/transformations\u0026quot; \u0026quot;strings\u0026quot; \u0026quot;testing\u0026quot; ) func TestToLower2(t *testing.T){ waf := coraza.NewWaf() parser, _ := seclang.NewParser(waf) if err := parser.FromString(\`SecRule ARGS:id \u0026quot;lowercase\u0026quot; \u0026quot;id:1, t:tolower2\u0026quot;\`); err != nil{ t.Error(err) } str := \u0026quot;TOLowEr\u0026quot; if strings.ToLower(str) != transformationToLowercase(str) { t.Error(\u0026quot;Transformation tolower2 failed\u0026quot;) } } Adding plugins to Coraza Plugin Repository # This feature will be available soon, in the meantime, you can edit this site and add plugins to plugins.html.
The site will update it\u0026rsquo;s database every 60 minutes, searching for projects with the coraza-plugin topic.
If the site fails to add the plugin to the database, it will create an issue with the details.
Requirements # The project must be public in github. The project must have the coraza-plugin keyword. The project must have a valid .coraza.yml file in the root path. The project must have a valid go.mod file .coraza.yml # This file will be used in the future by the Coraza Public Plugin Repository, it\u0026rsquo;s not required by the plugin itself.
.coraza.yml must be placed in the root directory of your repository and it must contain the following valid yaml structure:
# We only accept alphanumeric and -. ([\\w-]) name: some-plugin author: Your Full name or whatever you want to show repository: github.com/path/to-project # Coraza Plugin repository will only accept projects with apache2, MIT and BSD licenses, # we might accept more in the future license: apache2 description: Short description to display in plugins.coraza.io # We are using Ruby Gem version syntax: https://guides.rubygems.org/patterns/#pessimistic-version-constraint # The min supported Coraza version, each item represents an AND operator version: - \u0026quot;\u0026gt;= v1.1\u0026quot; - \u0026quot;\u0026lt; v2\u0026quot; # or ~\u0026gt; that is identical to the previous statements - \u0026quot;~\u0026gt; v1.1\u0026quot; tags: - Add some tags - For filtering defs: - name: even type: action|operator|transformation description: Will match if the number is even `}),e.add({id:31,href:"/docs/reference/",title:"Reference",description:"Coraza WAF API References.",content:""}),e.add({id:32,href:"/docs/tutorials/",title:"Tutorials",description:"Coraza WAF tutorials.",content:""}),e.add({id:33,href:"/docs/",title:"Use Cases",description:"OWASP Coraza WAF use cases.",content:""}),e.add({id:34,href:"/docs/seclang/",title:"Seclang",description:"Coraza WAF Docs.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()